# The JavaScript Object Model

Understanding the JavaScript object model, including prototypes, constructors, and class syntax,
is essential for working fluently with both JavaScript and TypeScript.

JavaScript uses a _prototype-based_ object model.
Unlike class-based languages, where classes define inheritance, JavaScript objects inherit from other objects directly.
This design supports powerful but sometimes non-intuitive behaviors.

## Object Fundamentals

### Objects Are Key-Value Maps

In JavaScript, all non-primitive values are objects.
Objects are collections of properties (keys and values) and can have methods (functions as values).

```ts
// Method shorthand (ES6)
const person1 = {
  name: "Alice",
  greet() {
    // 'this' refers to the 'person1' object:
    return `Hello, I'm ${this.name}` 
  }
}
console.log(person1.greet()) // Hello, I'm Alice

// Traditional function property
const person2 = {
  name: "Bob",
  greet: function () {
    return `Hello, I'm ${this.name}`
  }
}
console.log(person2.greet()) // Hello, I'm Bob

// Arrow function (not recommended for methods)
const person3 = {
  name: "Charlie",
  greet: () => `Hello, I'm ${this?.name}`
}
console.log(person3.greet()) // Hello, I'm undefined
```

This shows the three ways to define methods inside an object:

* **Method shorthand**: The preferred and concise ES6 syntax.
* **Traditional function property**: Fully explicit and works identically.
* **Arrow function**: Inherits `this` from the surrounding context; typically not what you want in object methods.

### Dynamic Modification

You can add or modify properties at runtime:

```ts
const book = {}
book.title = "1984"
book.author = "George Orwell"
console.log(book) // { title: "1984", author: "George Orwell" }
```

You can also delete properties:

```ts
delete book.author
console.log(book) // { title: "1984" }
```

### Object Utility Functions

JavaScript provides several utility functions for working with objects:

* `Object.create(proto)`: Creates a new object with the specified prototype.
* `Object.assign(target, source)`: Copies properties from source to target.
* `Object.entries(obj)`: Returns key-value pairs.
* `Object.keys(obj)`: Returns keys.
* `Object.values(obj)`: Returns values.

```ts
const o = { a: 1, b: 2 }
console.log(Object.entries(o)) // [['a', 1], ['b', 2]]
console.log(Object.keys(o))    // ['a', 'b']
console.log(Object.values(o))  // [1, 2]
```

### `this` and Method Binding

`this` always refers to the caller's context.
When passing methods around, you may lose the binding:

```ts
const user = {
  name: "Sam",
  greet() {
    return `Hello, ${this.name}`
  }
}

const greetRef = user.greet
console.log(greetRef()) // Hello, undefined
```

To fix this, bind the method:

```ts
const bound = user.greet.bind(user)
console.log(bound()) // Hello, Sam
```

## The Prototype System

Understanding JavaScript's prototype system is crucial for mastering the language.
This system underlies all object creation and inheritance in JavaScript, including modern class syntax.

### Constructor Functions

In JavaScript, a *constructor* is simply a function used to create new objects.
What makes a function a constructor isn't its declaration, but how it is called.
When a function is invoked with the `new` keyword, it acts as a constructor.

#### What `new` Does

Here's what happens when a function is called with `new`:

1. A new empty object is created
2. That object's prototype is set to the function's `.prototype` property
3. The constructor function is executed with `this` bound to the new object
4. If the function does not explicitly return an object, the new object is returned by default

```js
function Car(make, model) {
  this.make = make
  this.model = model
}

const myCar = new Car("Toyota", "Camry")
console.log(myCar) // { make: "Toyota", model: "Camry" }
console.log(myCar instanceof Car) // true
```

#### Any Function Can Be a Constructor

From a syntactic point of view, there's no special "constructor" keyword (outside of `class`) in JavaScript.
Any function can be used as a constructor simply by calling it with `new`.

Example of proper and improper usage:

```js
function Dog(name) {
  this.name = name
}

// Wrong: missing 'new' - this.name is set on global object (or undefined in strict mode)
const notADog = Dog("Buster")
console.log(notADog) // undefined

// Correct: using 'new' creates a proper Dog instance
const properDog = new Dog("Buster")
console.log(properDog) // { name: "Buster" }
```

#### Return Values in Constructors

Constructors typically don't return anything explicitly, but they *can*:

- If the constructor returns an **object** (e.g. `{}`), that object replaces the newly created one
- If it returns a **primitive value** (string, number, etc.), that value is ignored and the new object is returned as usual
- If it returns `undefined` (the default), the new object is returned

```js
function Custom() {
  this.foo = "bar"
  return { override: true } // This object is returned instead
}

const obj = new Custom()
console.log(obj) // { override: true }
console.log(obj.foo) // undefined
```

### The Prototype Property

Every function in JavaScript has a `prototype` property by default (except arrow functions).
This is an object that becomes the prototype of any instance created using that function as a constructor.

```js
function greet(name) {
  return `Hello, ${name}`
}

console.log(typeof greet.prototype) // "object"
console.log(greet.prototype) // greet: {} 
```

The `prototype` serves as the *shared space for instance methods and properties*.
Rather than duplicating methods for every instance, JavaScript allows all instances to delegate behavior to this shared prototype object.

#### When Does a Function Get a Prototype?

A function gets a `.prototype` property *as soon as it is defined*, even if the function is never used as a constructor.
It's simply part of how JavaScript sets up normal functions.

```js
function regularFunction() {}
console.log(typeof regularFunction.prototype) // "object"

// Arrow functions are the exception
const arrow = () => {}
console.log(arrow.prototype) // undefined
```

Arrow functions do not get a `.prototype` because they are not designed to be used with `new`.

#### The Constructor Property

The `.prototype.constructor` property points back to the function that created the prototype.
It is present by default and can be used to trace from an instance to its constructor.

```js
function Car(make, model) {
  this.make = make
  this.model = model
}

console.log(Car.prototype.constructor === Car) // true

const c = new Car("Toyota", "Camry")
console.log(c.constructor === Car) // true
```

JavaScript automatically creates the `Car.prototype` object like this:

```js
Car.prototype = {
  constructor: Car
}
```

The `constructor` property is just a reference back to the function that created the prototype, helping tools, debuggers, and humans know which function created instances linked to that prototype.

#### Adding Methods to the Prototype

You can add methods and properties to a constructor's prototype, making them available to all instances:

```js
function Car(make, model) {
  this.make = make
  this.model = model
}

// Add a shared method
Car.prototype.describe = function () {
  return `${this.make} ${this.model}`
}

// Add a shared property
Car.prototype.category = "vehicle"

const c1 = new Car("Toyota", "Camry")
const c2 = new Car("Honda", "Accord")

console.log(c1.describe()) // Toyota Camry
console.log(c2.describe()) // Honda Accord
console.log(c1.category)   // vehicle
console.log(c2.category)   // vehicle

// All instances share the same method
console.log(c1.describe === c2.describe) // true
```

#### Prototype Properties Are Live

If you add properties to a prototype after instances are created, those instances immediately gain access to the new properties:

```js
function Car(make, model) {
  this.make = make
  this.model = model
}

const c1 = new Car("Toyota", "Camry")
const c2 = new Car("Honda", "Civic")

// Add a new method after both objects were created
Car.prototype.describe = function () {
  return `${this.make} ${this.model}`
}

console.log(c1.describe()) // Toyota Camry
console.log(c2.describe()) // Honda Civic
```

This dynamic nature means modifying prototypes can have wide-reaching effects and should be done with caution.

#### Common Mistake: Adding to Instance Instead of Prototype

A common mistake is trying to add methods to an instance's prototype:

```js
c1.prototype.describe = function () {
  return `${this.make} ${this.model}`
}
```

This doesn't work because:
- `c1` is an instance, not a constructor
- Instances do not have a `prototype` property
- Only functions (which can be used as constructors) have a `.prototype` property

So `c1.prototype` is `undefined`, and assigning to it has no effect.

If you want to modify only `c1`, assign directly to the instance:

```js
c1.describe = function () {
  return `${this.make} ${this.model}`
}
```

#### Replacing the Entire Prototype

If you replace `.prototype` entirely, be sure to restore `.constructor` if needed:

```js
Car.prototype = {
  describe() {
    return `${this.make} ${this.model}`
  },
  constructor: Car // <- explicitly restore it
}
```

### Prototype Chain and Inheritance

JavaScript uses a *prototype chain* to implement inheritance.
When a property or method is accessed on an object, JavaScript follows this lookup process:

1. Does the object itself have the property?
2. If not, it follows the object's internal `[[Prototype]]` link to its constructor's prototype
3. This lookup continues up the chain until the property is found or the prototype is `null`

#### Basic Inheritance Example

Here's how to set up inheritance between constructor functions:

```js
function Animal(name) {
  this.name = name
}

Animal.prototype.speak = function() {
  return `${this.name} makes a generic sound`
}

function Dog(name, breed) {
  Animal.call(this, name) // Call parent constructor
  this.breed = breed
}

// Set up prototype chain: Dog -> Animal -> Object
Dog.prototype = Object.create(Animal.prototype)
Dog.prototype.constructor = Dog

// Override the parent method
Dog.prototype.speak = function() {
  return `${this.name} barks`
}

const fido = new Dog("Fido", "Golden Retriever")
console.log(fido.speak()) // "Fido barks"
console.log(fido instanceof Dog)    // true
console.log(fido instanceof Animal) // true
```

#### Understanding the Prototype Chain

The prototype chain for `fido` looks like this:

```text
fido → Dog.prototype → Animal.prototype → Object.prototype → null
```

You can verify this chain:

```js
console.log(Object.getPrototypeOf(fido) === Dog.prototype)           // true
console.log(Object.getPrototypeOf(Dog.prototype) === Animal.prototype) // true
console.log(Object.getPrototypeOf(Animal.prototype) === Object.prototype) // true
console.log(Object.getPrototypeOf(Object.prototype) === null)        // true
```

#### Method Resolution and Overriding

When `fido.speak()` is called, JavaScript searches the chain:

1. **fido** - no `speak` property directly on the instance
2. **Dog.prototype** - found! `speak` method exists here, so it's used
3. Animal.prototype.speak is never reached because Dog.prototype.speak was found first

This is how method overriding works in JavaScript's prototype system.

#### Accessing Parent Methods

If you want to call the parent method from an overridden method, you can do so explicitly:

```js
Dog.prototype.speak = function() {
  const parentSound = Animal.prototype.speak.call(this)
  return `${parentSound} - specifically, ${this.name} barks!`
}

console.log(fido.speak()) // "Fido makes a generic sound - specifically, Fido barks!"
```

#### The Internal `[[Prototype]]` Link

The double square brackets `[[Prototype]]` indicate an internal property of JavaScript objects that you cannot access directly using normal property syntax.
Instead, use these standard methods:

```js
// Reading an object's prototype
Object.getPrototypeOf(obj)

// Setting an object's prototype (avoid in performance-critical code)
Object.setPrototypeOf(obj, newProto)

// Creating an object with a specific prototype
Object.create(proto)
```

**Avoid the legacy `__proto__` accessor** - while it works in many environments, it's not part of the official standard and should not be used in production code.

#### Creating Objects with Specific Prototypes

You can create objects that inherit from other objects directly:

```js
const animal = {
  sound: "generic noise",
  speak() {
    return `Makes ${this.sound}`
  }
}

const dog = Object.create(animal)
dog.sound = "woof"
console.log(dog.speak()) // "Makes woof"

// The prototype chain: dog → animal → Object.prototype → null
```

#### Prototype Chain Termination

Every prototype chain eventually terminates at `Object.prototype`, whose prototype is `null`:

```js
const obj = {}
console.log(Object.getPrototypeOf(obj)) // Object.prototype
console.log(Object.getPrototypeOf(Object.prototype)) // null
```

You can create objects with no prototype using `Object.create(null)`:

```js
const dict = Object.create(null)
dict.key = "value"
console.log(dict.toString) // undefined: not inherited
```

This is useful for dictionary-like objects where you want to avoid conflicts with inherited properties like `toString` or `constructor`.

## Modern JavaScript Classes

ES6 introduced the `class` keyword as a more familiar way to declare constructors and prototypes, especially for developers coming from class-based languages like Java, C#, or C++.
Under the hood, classes still use the same prototype-based mechanism we've discussed.

### Basic Class Declaration

```js
class Shape {
  constructor(name) {
    this.name = name
  }
  
  describe() {
    return `This is a ${this.name}`
  }
}

const circle = new Shape("circle")
console.log(circle.describe()) // "This is a circle"

// Classes still create prototypes
console.log(Shape.prototype.describe) // [Function: describe]
console.log(circle instanceof Shape)  // true
```

### Class vs Constructor Function Equivalence

This class is functionally equivalent to the constructor function approach:

```js
// ES6 Class
class Animal {
  constructor(name) {
    this.name = name
  }
  
  speak() {
    return `${this.name} makes a sound`
  }
}

// Equivalent Constructor Function
function Animal(name) {
  this.name = name
}

Animal.prototype.speak = function() {
  return `${this.name} makes a sound`
}
```

Both create the same prototype structure, but classes provide cleaner syntax and better tooling support.

### Class Fields

You can define instance properties directly in the class body:

```js
class Counter {
  count = 0  // Instance field
  
  increment() {
    this.count++
  }
  
  get value() {
    return this.count
  }
}

const counter = new Counter()
console.log(counter.count) // 0
counter.increment()
console.log(counter.value) // 1
```

Class fields are added to each instance, not to the prototype.

### Class Inheritance with `extends`

Classes provide a clean syntax for inheritance using the `extends` keyword:

```js
class Animal {
  constructor(name) {
    this.name = name
  }
  
  speak() {
    return `${this.name} makes a sound`
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name)  // Call parent constructor
    this.breed = breed
  }
  
  speak() {
    return `${this.name} barks`
  }
  
  getBreed() {
    return this.breed
  }
}

const dog = new Dog("Rex", "German Shepherd")
console.log(dog.speak())    // "Rex barks"
console.log(dog.getBreed()) // "German Shepherd"
console.log(dog instanceof Dog)    // true
console.log(dog instanceof Animal) // true
```

### Using `super` to Access Parent Methods

The `super` keyword lets you call parent methods from overridden methods:

```js
class Dog extends Animal {
  speak() {
    const parentSound = super.speak()
    return `${parentSound} - specifically, a bark!`
  }
}

const dog = new Dog("Buddy")
console.log(dog.speak()) // "Buddy makes a sound - specifically, a bark!"
```

### Classes Enforce Constructor Usage

Unlike constructor functions, classes **must** be called with `new`:

```js
class Person {
  constructor(name) {
    this.name = name
  }
}

const person = new Person("Alice")  // ✓ Works
const error = Person("Alice")       // ✗ TypeError: Class constructor Person cannot be invoked without 'new'
```

This prevents the common mistake of forgetting `new` with constructor functions.

### Static Methods

Classes can have static methods that belong to the class itself, not instances:

```js
class MathUtils {
  static add(a, b) {
    return a + b
  }
  
  static PI = 3.14159
}

console.log(MathUtils.add(2, 3)) // 5
console.log(MathUtils.PI)        // 3.14159

const utils = new MathUtils()
console.log(utils.add)           // undefined (static methods aren't on instances)
```

### Benefits of Class Syntax

Classes provide several advantages over constructor functions:

- **Clearer intent**: It's clear when something is meant to be a constructor
- **Better tooling**: IDEs and linters can provide better support
- **Inheritance syntax**: `extends` and `super` are more intuitive than prototype chain setup
- **Error prevention**: Classes must be called with `new`
- **Future-proof**: New features like private fields work with class syntax

However, understanding the underlying prototype system remains important, as classes are syntactic sugar over the same fundamental mechanisms.

### TypeScript Class Enhancements

TypeScript enhances the class syntax with static type checking and convenient property declaration shortcuts:

```ts
type Point = { x: number; y: number };

class Circle {
  constructor(public center: Point, public radius: number) {}
  
  area(): number {
    return Math.PI * this.radius ** 2;
  }
}

const circle = new Circle({ x: 2, y: 2 }, 7);
```

The `public` modifier in the constructor parameters automatically creates and initializes instance properties, combining type safety with concise syntax.

## Advanced Techniques

Beyond the fundamental approaches we've covered, JavaScript offers several specialized patterns for creating objects.
These techniques are useful in specific scenarios or when you need fine-grained control over object behavior.

### Static Factory Methods

Static factory methods provide alternative constructors with more descriptive names and can perform validation or choose different implementations:

```js
class Rectangle {
  constructor(width, height) {
    this.width = width
    this.height = height
  }
  
  static square(size) {
    return new Rectangle(size, size)
  }
  
  static fromArea(area, aspectRatio = 1) {
    const width = Math.sqrt(area * aspectRatio)
    const height = area / width
    return new Rectangle(width, height)
  }
  
  area() {
    return this.width * this.height
  }
}

const square = Rectangle.square(5)
const rect = Rectangle.fromArea(100, 2)
```

### `Object.defineProperty` for Fine-Grained Control

When you need precise control over property behavior—such as read-only properties, hidden properties, or custom getters/setters:

```js
function createImmutablePoint(x, y) {
  const point = {}
  
  Object.defineProperties(point, {
    x: {
      value: x,
      writable: false,
      enumerable: true
    },
    y: {
      value: y,
      writable: false,
      enumerable: true
    },
    distance: {
      get() {
        return Math.sqrt(this.x ** 2 + this.y ** 2)
      },
      enumerable: true
    }
  })
  
  return point
}

const point = createImmutablePoint(3, 4)
console.log(point.distance) // 5
point.x = 10 // Silently ignored (or throws in strict mode)
```

### Proxy-Based Objects

Proxies allow you to intercept and customize operations on objects, enabling powerful metaprogramming:

```js
function createValidatedUser(name, email) {
  const data = { name, email }
  
  return new Proxy(data, {
    set(target, property, value) {
      if (property === 'email' && !value.includes('@')) {
        throw new Error('Invalid email format')
      }
      if (property === 'name' && typeof value !== 'string') {
        throw new Error('Name must be a string')
      }
      target[property] = value
      return true
    },
    
    get(target, property) {
      if (property === 'displayName') {
        return `${target.name} <${target.email}>`
      }
      return target[property]
    }
  })
}

const user = createValidatedUser("Alice", "alice@example.com")
console.log(user.displayName) // "Alice <alice@example.com>"
user.email = "invalid-email"  // Error: Invalid email format
```

### Singleton Pattern with Module Closure

Create objects that should only exist once using module patterns:

```js
const DatabaseConnection = (function() {
  let instance = null
  let connectionCount = 0
  
  function createConnection() {
    return {
      id: ++connectionCount,
      query(sql) {
        return `Executing: ${sql}`
      },
      close() {
        console.log(`Connection ${this.id} closed`)
      }
    }
  }
  
  return {
    getInstance() {
      if (!instance) {
        instance = createConnection()
      }
      return instance
    }
  }
})()

const db1 = DatabaseConnection.getInstance()
const db2 = DatabaseConnection.getInstance()
console.log(db1 === db2) // true
```

### Symbol-Based Private Methods

Use symbols to create "private" methods that don't appear in normal property enumeration:

```js
const _privateMethod = Symbol('privateMethod')
const _privateData = Symbol('privateData')

class SecureContainer {
  constructor(data) {
    this[_privateData] = data
  }
  
  [_privateMethod]() {
    return `Processing: ${this[_privateData]}`
  }
  
  process() {
    return this[_privateMethod]()
  }
  
  // Public method to access the symbol (for testing/debugging)
  static getPrivateMethod() {
    return _privateMethod
  }
}

const container = new SecureContainer("secret")
console.log(container.process()) // "Processing: secret"
console.log(Object.keys(container)) // [] (symbols don't appear)
```

### Object Reconstruction from JSON

When working with data from APIs or storage, you often need to restore methods to plain objects:

```js
class Task {
  constructor(title, completed = false) {
    this.title = title
    this.completed = completed
    this.createdAt = new Date()
  }
  
  toggle() {
    this.completed = !this.completed
  }
  
  // Static method to reconstruct from plain object
  static fromJSON(json) {
    const data = typeof json === 'string' ? JSON.parse(json) : json
    const task = Object.assign(new Task(data.title, data.completed), data)
    task.createdAt = new Date(data.createdAt)
    return task
  }
}

// Simulate API data
const jsonData = '{"title":"Learn JavaScript","completed":false,"createdAt":"2023-01-01T00:00:00.000Z"}'
const task = Task.fromJSON(jsonData)
task.toggle() // Method works because we reconstructed the object properly
```

### Mixin Pattern

Create reusable behavior that can be mixed into multiple classes:

```js
const Serializable = {
  serialize() {
    return JSON.stringify(this)
  },
  
  deserialize(json) {
    const data = JSON.parse(json)
    Object.assign(this, data)
    return this
  }
}

const Timestamped = {
  touch() {
    this.lastModified = new Date()
    return this
  }
}

class Document {
  constructor(title, content) {
    this.title = title
    this.content = content
  }
}

// Mix in behaviors
Object.assign(Document.prototype, Serializable, Timestamped)

const doc = new Document("My Doc", "Content here")
doc.touch()
console.log(doc.serialize()) // JSON string with lastModified timestamp
```

### When to Use These Patterns

- **Static factory methods**: When you have multiple ways to construct objects or need validation
- **Object.defineProperty**: When you need immutable properties or computed properties
- **Proxies**: For debugging, reactive systems, or dynamic behavior (use sparingly due to performance cost)
- **Singletons**: For shared resources like database connections or configuration objects
- **Symbol methods**: When you need "private" methods in classes (before private fields were available)
- **JSON reconstruction**: When working with APIs or persisted data
- **Mixins**: When you need to share behavior across unrelated classes

These patterns demonstrate JavaScript's flexibility, but remember that simpler approaches (classes, factory functions, object literals) should be your default choices unless you have specific requirements that these advanced patterns address.

## Key Concepts

JavaScript's object model is fundamentally different from class-based languages.
By understanding how prototypes work, you gain insight into how JavaScript implements inheritance and method sharing.
Modern class syntax provides a familiar interface while preserving the flexibility of the underlying prototype system.

- **Objects are dynamic collections** of properties that can be modified at runtime
- **Prototypes enable inheritance** through a chain of linked objects
- **Constructor functions** create objects by setting up prototype relationships
- **Classes provide syntactic sugar** over the prototype system with better tooling and error prevention
- **Advanced patterns** offer specialized solutions for specific use cases

Mastering these concepts will make you more effective at both reading existing JavaScript code and writing maintainable object-oriented programs in JavaScript and TypeScript.
