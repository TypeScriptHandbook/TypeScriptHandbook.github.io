# Generics

Generic programming in TypeScript allows precise typing while enabling broad code reuse.
Constraints help enforce assumptions, and type defaults improve ergonomics.
By parameterizing types, you can describe relationships between input and output types, enforce structure, and support inference.
However, understanding inference behavior is essential to getting the most out of generics.

## Generic Functions and Types

A basic generic function uses a type parameter to generalize input and output:

```ts
function identity<T>(value: T): T {
  return value
}

const a = identity("hello")  // a: string
const b = identity(42)       // b: number
```

You can also create generic types:

```ts
type Box<T> = {
  value: T
}

const stringBox: Box<string> = { value: "wrapped" }
const numberBox: Box<number> = { value: 99 }
```

Generics can be used in arrays, promises, and classes.

```ts
stringArray: Array<string> = ["a", "b"]
const numberPromise: Promise<number> = Promise.resolve(1)

class Container<T> {
  constructor(public value: T) {}

  get(): T {
    return this.value
  }
}

const numberContainer = new Container<number>(123)
console.log(numberContainer.get()) // 123

const stringContainer = new Container("hello")
console.log(stringContainer.get()) // "hello"

// Also works with complex types:
const pointContainer = new Container({ x: 1, y: 2 })
console.log(pointContainer.get().x) // 1
```

## Constraint-Based Design

You can constrain generic types to require certain properties using `extends`:

```ts
function lengthOf<T extends { length: number }>(value: T): number {
  return value.length
}

lengthOf("hello")        // 5
lengthOf([1, 2, 3])       // 3
// lengthOf(42)          // Error: number doesn't have a length
```

This allows generic functions to operate safely on a restricted set of shapes.

Interfaces and types can also declare constrained generics:

```ts
interface HasId<T extends { id: number }> {
  item: T
}

const record: HasId<{ id: number; name: string }> = {
  item: { id: 1, name: "Item" }
}
```

## Type Defaults and Inference Quirks

You can specify default types for generic parameters:

```ts
type Response<T = string> = {
  data: T
}

const r1: Response = { data: "ok" }          // uses default string
const r2: Response<number> = { data: 200 }   // overrides default
```

However, TypeScript does not always infer the most specific type:

```ts
function wrap<T>(value: T): { value: T } {
  return { value }
}

const result = wrap("hello")  // inferred as string

// But inference is shallow:
const complex = wrap({ x: 1 })
// complex.value.x inferred as number, but not deeply readonly
```

To improve inference, you may use helper types or `as const`:

```ts
const config = wrap({ mode: "dark" } as const)
// Now config.value.mode is the literal type "dark"
```

## Variance

*Variance* governs how subtyping works with generic types, particularly when those types are used in function parameters and return values. Understanding variance helps you reason about type relationships and safety in complex type declarations.

### Covariance

A type constructor is *covariant* in a type parameter when it preserves the subtyping relationship:

```ts
type ReadOnlyBox<T> = {
  readonly value: T
}

const stringBox: ReadOnlyBox<string> = { value: "hello" }
const widerBox: ReadOnlyBox<string | number> = stringBox // OK
```

Since `ReadOnlyBox` does not allow mutation, it's safe to assign a more specific type to a more general one.

### Contravariance

Function parameter types are *contravariant*, meaning they reverse the subtyping relationship:

```ts
type Printer<T> = (value: T) => void

const printString: Printer<string> = str => console.log(str)
const printUnknown: Printer<unknown> = printString // OK
```

Here, `printUnknown` can accept any `Printer<T>` for a *specific* `T`, because it's always safe to pass a function that accepts fewer types than the caller expects.

### Bivariance and Invariance

Function parameters are *bivariant* in some contexts for backwards compatibility, meaning TypeScript may allow both subtype and supertype assignments. This is unsound in strict terms, so enabling `strictFunctionTypes` makes TypeScript enforce proper variance rules.

```ts
type Handler = (event: MouseEvent) => void

const handleUI: Handler = (event: UIEvent) => {
  // Error in strictFunctionTypes: UIEvent not assignable to MouseEvent
}
```

Most types are *invariant* when used in mutable positions:

```ts
type Box<T> = { value: T }

let numberBox: Box<number> = { value: 42 }
// let stringBox: Box<string> = numberBox // Error: Box<string> not assignable to Box<number>
```

Understanding variance allows you to design safer APIs and compose types with confidence.

### Variance Annotations

As of the latest version of TypeScript, you can now use the `in`, `out`, and `in out` keywords directly in generic type declarations to express variance explicitly. This feature allows you to document and guide the intended usage of type parameters within your code.

```ts
interface Producer<out T> {
  produce(): T
}

interface Consumer<in T> {
  consume(value: T): void
}

interface Transformer<in out T> {
  transform(value: T): T
}
```

These modifiers mean:

* `out T`: T is used only in output positions (covariant)
* `in T`: T is used only in input positions (contravariant)
* `in out T`: T is used in both directions (invariant)

This syntax allows the compiler and tools to reason more precisely about how types are used, improving expressiveness and safety in generic APIs.

Keep in mind that the actual enforcement of these annotations may still be limited, depending on the compiler settings and ecosystem support, 
but they represent an important step forward in expressing type relationships directly in TypeScript's type system.
