# JavaScript: The TypeScript Substrate

If you’re coming from a background in strongly-typed languages like Java, Rust, C#, or Haskell, JavaScript might initially appear bewildering. Its loose, dynamic typing, implicit type coercions, and eccentric runtime behaviors seem almost engineered to confuse. Yet it’s precisely this flexibility that made JavaScript successful in its original role as a browser scripting language.

JavaScript was designed in ten days and shipped with only modest expectations. But through a confluence of historical and economic forces—namely the browser wars and the rise of web applications—JavaScript became the default language of client-side programming.

Unlike many modern languages, JavaScript evolved through accretion rather than intentional design. It inherited paradigms from multiple languages: first-class functions from Scheme, prototype-based inheritance from Self, and syntax loosely based on Java. Over time, these eclectic roots have given it a powerful but chaotic feature set.

Consider the following quirks:

```js
[] + []     // ""
[] + {}     // "[object Object]"
{} + []     // 0

false == 0         // true
false === 0        // false
NaN === NaN        // false
typeof null        // "object"
```

These examples are not pathological edge cases—they reflect the daily reality of JavaScript developers.

For all its quirks, JavaScript is incredibly expressive and accessible. The problem is not that it is dynamic, but that it offers no way to constrain or document intent in large systems. This makes refactoring risky and APIs ambiguous.

## Why TypeScript Had to Exist

JavaScript's success as the universal scripting language came at a cost: it wasn't designed for scale. 
As web applications grew larger and more complex, development teams increasingly needed tools that would:

* Catch errors earlier
* Document contracts between modules
* Enable better IDE support (autocomplete, navigation, refactoring)

TypeScript emerged to meet this need. Initially conceived by Microsoft as a typed superset of JavaScript, TypeScript introduced a gradual type system that was expressive enough to model most JavaScript idioms without requiring wholesale rewrites.

Instead of replacing JavaScript, TypeScript embraces it. Any JavaScript file is a valid TypeScript file. This made adoption incremental and non-disruptive—a crucial factor in its widespread success.

While TypeScript adds structure, it also respects JavaScript’s dynamic core. It does not aim for soundness in the way that languages like Haskell or Rust do. Its goal is developer productivity, not formal correctness.

In that spirit, this book will assume that you’re fluent in at least two programming languages, and want to understand the sometimes beautiful, sometimes bewildering foundations upon which TypeScript is built.
