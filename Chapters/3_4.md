# Type Transformations

Conditional and mapped types provide powerful tools for transforming types.
They encode logic into the type system itself, enabling flexible, reusable, and expressive type definitions.
They let you:

* Perform conditional branching (`extends ? :`)
* Extract types (`infer`)
* Define recursive patterns
* Transform, filter, and remap keys
* Combine transformations for high-level type logic

Together, they provide the foundation for most advanced type-level programming in TypeScript.

## Conditional Types

A conditional type selects one of two possible types depending on a condition.
They follow this form:

```ts
T extends U ? X : Y
```

Read: "If `T` is assignable to `U`, then the type is `X`, otherwise it's `Y`."

We typically use conditional types with generics:

```ts
type IsString<T> = T extends string ? true : false
type A = IsString<string>  // true
type B = IsString<number>  // false
```

Conditional types are evaluated entirely at compile time. 
In the above example, `IsString<string>` resolves to `true` because `string` extends `string` is `true`. 
Likewise, `IsString<number>` resolves to `false`.

We assign the result of a conditional type to a type alias (e.g., `type A = ...`) because conditional types are purely type-level logic; they do not exist at runtime.
Assigning to a type alias lets us reference and reuse the result in other type declarations, enabling composable and readable type logic. 
Typically, we use these aliases in further type-level computations or constraints rather than trying to instantiate values of those types, 
since types like true or false from a conditional aren't usually used directly in value-level code. 
In this way, the `type` keyword acts similarly to `const`: it creates an immutable alias in the type system that cannot be reassigned, 
though it has no runtime presence like `const` does.

```ts
type A = { kind: "A" }
type B = { kind: "B" }

type SelectType<T> = T extends string ? A : B

function create<T>(value: T): SelectType<T> {
  return (typeof value === "string"
    ? { kind: "A" }
    : { kind: "B" }) as SelectType<T>
}

console.log(create("hello")) // { kind: "A" }
console.log(create(123)) // { kind: "B" }
```

The return type of `create<T>` is defined using the conditional type `SelectType<T>`. 
This type evaluates whether `T` extends `string`. 
If it does, the result is type `A`; otherwise, it is type `B`. 
At runtime, the `create` function performs a corresponding check with `typeof`, returning a structure that matches the expected type.

Note that the type of the return value is determined at compile time by the `SelectType<T>` conditional type.
The `create` function appears to return different types depending on the input.
However, the real differentiation happens entirely within the type system, at compile time.
TypeScript performs static analysis and infers the return type based on the argument type at each call site.

All type information is erased and unavailable in the emitted JS code. 
Thus, the type information can only be used in other parts of the code at compile time.
The function logic at runtime is generic, but the compiler enforces precise return types for each usage. 
This way, conditional types enable expressive compile-time logic without adding complexity to the generated JavaScript. 
Even though the same function body handles both cases, TypeScript ensures that the resulting type is narrowed based on the argument type passed to create.

### Using `infer` to Extract Types

The `infer` keyword introduces a type variable to be inferred in a conditional type:

```ts
type ElementType<T> = T extends (infer U)[] ? U : T

// Usage:
type A = ElementType<string[]>   // string
type B = ElementType<number>     // number
```

- `T extends (infer U)[]` checks whether the type `T` is assignable to an array type.
- If `T` is an array type, `infer U` extracts the element type of that array and returns it.
- If `T` is not an array type, it simply returns `T` itself.

You can use `infer` to extract argument types from functions:

```ts
type ArgumentType<T> = T extends (arg: infer A) => any ? A : never

type Fn = (x: boolean) => void

type Arg = ArgumentType<Fn>  // boolean
```

And multiple parameters:

```ts
type ParametersOf<T> = T extends (...args: infer P) => any ? P : never

type MyFn = (x: string, y: number) => void

type Params = ParametersOf<MyFn>  // [string, number]
```

### Recursive Conditional Types

Conditional types can be recursive, enabling powerful type-level computations:

```ts
type Flatten<T> = T extends (infer U)[] ? Flatten<U> : T

type A = Flatten<number[][][]>  // number
```

Recursive types are useful for deeply nested structures or list processing.

## Template Literal Types

Template literal types enable constructing new string literal types by concatenating or interpolating string literals:

```ts
// Combine literal types:
type Lang = "en" | "fr"
type FileExtension = ".json" | ".txt"
type Filename = `${Lang}${FileExtension}`

const file: Filename = "en.json" // OK
```

You can use `infer` and `extends` with template literals to extract and manipulate parts of string types:

```ts
type ExtractLang<T> = T extends `${infer L}.${string}` ? L : never

type Lang1 = ExtractLang<"en.json"> // "en"
type Lang2 = ExtractLang<"fr.txt"> // "fr"
```

This allows the type system to analyze string structures at compile time.

## `keyof` and Indexed Access Types

The `keyof` operator produces a union of the keys of a type:

```ts
type Person = {
  name: string
  age: number
}

type PersonKeys = keyof Person // "name" | "age"
```

You can access the type of a specific property using indexed access:

```ts
type AgeType = Person["age"] // number
```

If used with `keyof`, you can define generic utility types:

```ts
type ValueOf<T> = T[keyof T]
type PersonValues = ValueOf<Person> // string | number
```

## `typeof` and `as const`

You can use `typeof` to get the type of a value:

```ts
const config = {
  host: "localhost",
  port: 8080
}

type ConfigType = typeof config
// Equivalent to:
// type ConfigType = { host: string; port: number }
```

When combined with `as const`, you can preserve literal types:

```ts
const status = {
  loading: "loading",
  success: "success"
} as const

type Status = typeof status[keyof typeof status] // "loading" | "success"
```

Without `as const`, the values would widen to `string`.
With `as const`, they retain their literal values.

## Mapped Types

Mapped types transform all the properties of an existing type, using an _index signature_ as introduced in Chapter 2.3:

```ts
type Options = {
  darkMode: boolean
  fontSize: number
}

type PartialOptions = {
  [K in keyof Options]?: Options[K]
}
```

- `keyof Options` produces a union of the keys of the `Options` type (e.g., `"darkMode" | "fontSize"`).
- `K in keyof Options` iterates over each of those keys.
- The `?` makes each key optional.
- `Options[K]` is the type of the corresponding property.

In essence, this creates a new type with all the same keys as Options, but where each property is optional and retains the original type.
This creates a type where all properties of `Options` are optional:

```ts
type PartialOptions = {
  darkMode?: boolean
  fontSize?: number
}
```

### Predefined Mapped Types

TypeScript provides a set of built-in mapped types that are globally available and do not require explicit import. 

| Utility Type               | Description                                                                          |
|----------------------------|--------------------------------------------------------------------------------------|
| `Partial<T>`               | Makes all properties in `T` optional.                                                |
| `Required<T>`              | Makes all properties in `T` required (removes optional `?`).                         |
| `Readonly<T>`              | Makes all properties in `T` readonly.                                                |
| `Mutable<T>`               | Removes `readonly` from all properties (not built-in, but commonly defined).         |
| `Pick<T, K>`               | Selects a subset of properties from `T` specified by `K`.                            |
| `Omit<T, K>`               | Removes a subset of properties from `T` specified by `K`.                            |
| `Record<K, T>`             | Constructs an object type with keys of `K` and values of type `T`.                   |
| `Exclude<T, U>`            | Excludes from `T` those types that are assignable to `U`.                            |
| `Extract<T, U>`            | Extracts from `T` those types that are assignable to `U`.                            |
| `NonNullable<T>`           | Removes `null` and `undefined` from `T`.                                             |
| `ReturnType<T>`            | Gets the return type of a function type `T`.                                         |
| `Parameters<T>`            | Gets the parameters tuple of a function type `T`.                                    |
| `ConstructorParameters<T>` | Gets the parameter types of a constructor function type `T`.                         |
| `InstanceType<T>`          | Gets the instance type of a constructor function type `T`.                           |
| `ThisParameterType<T>`     | Extracts the type of the `this` parameter for function type `T`.                     |
| `OmitThisParameter<T>`     | Removes the `this` parameter from function type `T`.                                 |
| `ThisType<T>`              | A marker for contextual `this` in object literals (used only for contextual typing). |
| `Awaited<T>`               | Extracts the type wrapped in a `Promise` or similar `Thenable`.                      |
| `Uppercase<S>`             | Converts a string literal type `S` to uppercase.                                     |
| `Lowercase<S>`             | Converts a string literal type `S` to lowercase.                                     |
| `Capitalize<S>`            | Capitalizes the first character of a string literal type `S`.                        |
| `Uncapitalize<S>`          | Un-capitalizes the first character of a string literal type `S`.                     |

Each of these is implemented using mapped type syntax and serves a common utility for transforming types. 
Here are definitions of some of the most widely used built-in mapped types:

```ts
type Partial<T> = {
  [P in keyof T]?: T[P]
}

type Readonly<T> = {
  readonly [P in keyof T]: T[P]
}

type Required<T> = {
  [P in keyof T]-?: T[P]
}

type Mutable<T> = {
  -readonly [P in keyof T]: T[P]
}
```

The `-` in this context _removes the modifier_.
Here, `-?` removes the optional modifier, making each property required, and `-readonly` removes the `readonly` modifier, making properties mutable.

You can combine modifiers:

```ts
type FullyMutable<T> = {
  -readonly [P in keyof T]-?: T[P]
}
```

## Key Remapping and Filtering

You can remap keys using mapped types:

```ts
type PrefixKeys<T> = {
  [K in keyof T as `prefix_${string & K}`]: T[K]
}

// Example:
type Input = { name: string; age: number }
type Prefixed = PrefixKeys<Input>
// { prefix_name: string; prefix_age: number }
```

You can also filter keys:

```ts
type OnlyStrings<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K]
}

// Example:
type Mixed = { a: string; b: number; c: string }
type StringsOnly = OnlyStrings<Mixed>
// { a: string; c: string }
```

For each key, if the property's type `T[K]` extends `string`, it keeps `K` in the result.
Otherwise, it maps `K` to `never`, which effectively removes that key from the resulting type.
Thus, it filters the keys of `T` based on whether their values are of type `string`.

## Template Literal Types with Mapped Types

You can use template literals to create new key names:

```ts
type EventHandlers<T> = {
  [K in keyof T & string as `on${Capitalize<K>}`]: () => void
}

// Example:
type UI = { click: boolean; focus: boolean }
type Handlers = EventHandlers<UI>
// { onClick: () => void; onFocus: () => void }
```

## Conditional Logic in Mapped Types

Conditional logic can be used inside mapped types.
Here, we make an object's fields nullable in a type-safe way while preserving fields that are already explicitly nullable:

```ts
type NullableFields<T> = {
  [K in keyof T]: null extends T[K] ? T[K] : T[K] | null
}

// Example:
type Person = { name: string; bio: string | null }
type WithNullable = NullableFields<Person>
// { name: string | null; bio: string | null }
```

- `K in keyof T` iterates over all keys `K` of the object type `T`.
- `null extends T[K]` checks whether the type of the property `T[K]` already includes `null`.
- `? T[K] : T[K] | null` means that if `T[K]` already allows `null`, leave it unchanged. Otherwise, add `null` to the union.

This results in a type where every property becomes nullable unless it was already nullable.
