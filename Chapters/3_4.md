# Chapter 3.4: Conditional Types and Mapped Types

Conditional and mapped types provide powerful tools for transforming types in TypeScript.
They allow logic to be encoded into the type system itself, enabling flexible, reusable, and expressive type definitions.

---

## Conditional Types

A conditional type selects one of two possible types depending on a condition.
They follow this form:

```ts
T extends U ? X : Y
```

Read: "If `T` is assignable to `U`, then the type is `X`, otherwise it's `Y`."

We typically use conditional types with generics:

```ts
type IsString<T> = T extends string ? true : false
type A = IsString<string>  // true
type B = IsString<number>  // false
```

Conditional types are evaluated entirely at compile time. 
In the above example, IsString<string> resolves to true because string extends string is true. Likewise, IsString<number> resolves to false.

We assign the result of a conditional type to a type alias (e.g., type A = ...) because conditional types are purely type-level logic—they do not exist at runtime.
Assigning to a type alias lets us reference and reuse the result in other type declarations, enabling composable and readable type logic. 
Typically, we use these aliases in further type-level computations or constraints rather than trying to instantiate values of those types, 
since types like true or false from a conditional aren't usually used directly in value-level code. 
In this way, the type keyword acts similarly to const—it creates an immutable alias in the type system that cannot be reassigned, 
though it has no runtime presence like const does.

```ts
type A = { kind: "A" }
type B = { kind: "B" }

type SelectType<T> = T extends string ? A : B

function create<T>(value: T): SelectType<T> {
  return (typeof value === "string"
    ? { kind: "A" }
    : { kind: "B" }) as SelectType<T>
}

console.log(create("hello")) // { kind: "A" }
console.log(create(123)) // { kind: "B" }
```

The return type of create<T> is defined using the conditional type SelectType<T>. 
This type evaluates whether T extends string. If it does, the result is type A; otherwise, it is type B. 
At runtime, the create function performs a corresponding check with typeof, returning a structure that matches the expected type.

Note that the type of the return value is determined at compile time by the SelectType<T> conditional type. 
TypeScript performs static analysis and infers the return type based on the argument type at each call site.

All type information is erased and unavailable in the emitted JS code. 
Thus, the type information can only be used in other parts of the code at compile time.

The `create` function appears to return different types depending on the input. 
However, the real differentiation happens entirely within the type system, at compile time. 
The function logic at runtime is generic, but the compiler enforces precise return types for each usage. 
In this way, conditional types enable expressive compile-time logic without adding complexity to the generated JavaScript. 
Even though the same function body handles both cases, TypeScript ensures that the resulting type is narrowed based on the argument type passed to create.

### Using `infer` to Extract Types

The `infer` keyword introduces a type variable to be inferred in a conditional type:

```ts
type ElementType<T> = T extends (infer U)[] ? U : T

// Usage:
type A = ElementType<string[]>   // string
type B = ElementType<number>     // number
```

You can use `infer` to extract argument types from functions:

```ts
type ArgumentType<T> = T extends (arg: infer A) => any ? A : never

type Fn = (x: boolean) => void

type Arg = ArgumentType<Fn>  // boolean
```

And multiple parameters:

```ts
type ParametersOf<T> = T extends (...args: infer P) => any ? P : never

type MyFn = (x: string, y: number) => void

type Params = ParametersOf<MyFn>  // [string, number]
```

### Recursive Conditional Types

Conditional types can be recursive, enabling powerful type-level computations:

```ts
type Flatten<T> = T extends (infer U)[] ? Flatten<U> : T

type A = Flatten<number[][][]>  // number
```

Recursive types are useful for deeply nested structures or list processing.

---

## Mapped Types

Mapped types transform all the properties of an existing type:

```ts
type Options = {
  darkMode: boolean
  fontSize: number
}

type PartialOptions = {
  [K in keyof Options]?: Options[K]
}
```

This creates a type where all properties of `Options` are optional.

### Built-In Mapped Type Examples

```ts
type Partial<T> = {
  [P in keyof T]?: T[P]
}

type Readonly<T> = {
  readonly [P in keyof T]: T[P]
}

type Required<T> = {
  [P in keyof T]-?: T[P]
}

type Mutable<T> = {
  -readonly [P in keyof T]: T[P]
}
```

You can combine modifiers:

```ts
type FullyMutable<T> = {
  -readonly [P in keyof T]-?: T[P]
}
```

---

## Key Remapping and Filtering

You can remap keys in mapped types:

```ts
type PrefixKeys<T> = {
  [K in keyof T as `prefix_${string & K}`]: T[K]
}

// Example:
type Input = { name: string; age: number }
type Prefixed = PrefixKeys<Input>
// { prefix_name: string; prefix_age: number }
```

You can also filter keys:

```ts
type OnlyStrings<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K]
}

// Example:
type Mixed = { a: string; b: number; c: string }
type StringsOnly = OnlyStrings<Mixed>
// { a: string; c: string }
```

---

## Template Literal Types with Mapped Types

You can use template literals to create new key names:

```ts
type EventHandlers<T> = {
  [K in keyof T & string as `on${Capitalize<K>}`]: () => void
}

// Example:
type UI = { click: boolean; focus: boolean }
type Handlers = EventHandlers<UI>
// { onClick: () => void; onFocus: () => void }
```

---

## Combining Conditional and Mapped Types

Conditional logic can be used inside mapped types:

```ts
type NullableFields<T> = {
  [K in keyof T]: null extends T[K] ? T[K] : T[K] | null
}

// Example:
type Person = { name: string; bio: string | null }
type WithNullable = NullableFields<Person>
// { name: string | null; bio: string | null }
```

This technique helps make optional or nullable transformations.

---

## Summary

Conditional and mapped types allow powerful transformations of the type system.
They let you:

* Perform conditional branching (`extends ? :`)
* Extract types (`infer`)
* Define recursive patterns
* Transform, filter, and remap keys
* Combine transformations for high-level type logic

Together, they provide the foundation for most advanced type-level programming in TypeScript.
