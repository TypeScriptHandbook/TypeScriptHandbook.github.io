# Type Inference and Control

TypeScript uses type inference to reduce the need for explicit annotations. 
It infers types based on assignments, operations, function returns, and more. 
You can also refine these inferred types using narrowing and contextual cues.

## Basic Inference

When you assign a value to a variable, TypeScript infers its type:

```ts
let age = 42 // inferred as number
const name = "Alice" // inferred as "Alice" (literal type)
```

Function return types are inferred if not specified:

```ts
function square(x: number) {
  return x * x // inferred as number
}
```

## Type Narrowing

TypeScript refines types based on control flow, such as conditionals and checks:

```ts
function print(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()) // narrowed to string
  } else {
    console.log(value.toFixed(2)) // narrowed to number
  }
}
```

Other narrowing mechanisms include:

* `in` operator: check for presence of a property

```ts
type Cat = { meow: () => void }
type Dog = { bark: () => void }

declare const pet: Cat | Dog

if ("meow" in pet) {
  pet.meow() // narrowed to Cat
} else {
  pet.bark() // narrowed to Dog
}
```

* `instanceof`: check against constructor functions. This only works on objects that have been created by a constructor.

```ts
class Circle {
  radius = 1
}
class Square {
  side = 2
}

// Constructed instances:
const shape: Circle | Square = new Circle()

if (shape instanceof Circle) {
  console.log("Constructed Circle with radius", shape.radius)
} else {
  console.log("Constructed Square with side", shape.side)
}

// Non-constructed objects with the same shape:
const pseudoShape = { radius: 10 }
console.log(pseudoShape instanceof Circle) // false
```

* Equality checks against literals

```ts
type Status = "loading" | "success" | "error"

declare const status: Status

if (status === "success") {
  console.log("Operation successful")
} else if (status === "error") {
  console.log("Operation failed")
}
```

* Custom type predicates: functions that tell TypeScript the specific type of a value within a union type, based on user-defined logic:

```ts
type Fish = { swim: () => void }
type Bird = { fly: () => void }

function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined
}

declare const pet: Fish | Bird

if (isFish(pet)) {
  pet.swim()
} else {
  pet.fly()
}
```

The return type ``pet is Fish` is the _type predicate_. It tells TypeScript that when the function returns `true`, the `pet` value should be treated as having type `Fish` in the surrounding scope. This enables precise narrowing and safe access to Fish-specific properties. If isFish succeeds, the TypeScript compiler treats the object as a `Fish`` from then on.

## Contextual Typing

When the surrounding context expects a type, TypeScript uses that to infer it. This often occurs in callbacks:

```ts
const numbers = [1, 2, 3]
numbers.forEach(n => {
  console.log(n * 2) // n is inferred as number
})
```

Another example is in event handlers:

```ts
window.addEventListener("click", e => {
  console.log(e.clientX) // e is inferred as MouseEvent
})
```

Contextual typing allows many APIs to work without needing explicit parameter annotations.
