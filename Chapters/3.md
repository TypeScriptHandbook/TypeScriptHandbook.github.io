# Keywords and Operators

Introduces the essential keywords and operators in JavaScript and TypeScript. 
Each entry includes a short definition, example, and usage notes.

## Declarations and Scope

`var`: Declares a function-scoped variable. Hoisted; may lead to unexpected behavior.

```ts
function demo() {
  console.log(x) // undefined
  var x = 5
}
```

`let`: Declares a block-scoped mutable variable.

```ts
let count = 1
count++
```

`const`: Declares a block-scoped constant. Value cannot be reassigned.

```ts
const name = "Alice"
// name = "Bob" // Error
```

`function`: Declares a function. Functions are hoisted.

```ts
function add(x: number, y: number): number {
  return x + y
}
```

`class`: Declares a class (syntactic sugar over prototypes).

```ts
class Circle {
  constructor(public radius: number) {}
}
const c = new Circle(5)
console.log(c.radius) // 5
```

`interface`: Declares a shape of an object or class. Only in TypeScript.

```ts
interface Point {
  x: number
  y: number
}

const p: Point = { x: 1, y: 2 }
```

`type`: Declares an alias for a type. Supports unions, intersections, etc.

```ts
type Status = "loading" | "done"
const s: Status = "done"
```

`import` / `export`: share and consume modules.

```ts
import { something } from "./module"
export function doSomething() {}
```

`enum`: Declares a set of named constants.

```ts
enum Direction {
  Up,
  Down
}
const dir: Direction = Direction.Up

enum Color {
  Red = 0,
  Blue = 1
}

const dir: Color = Color.Red
console.log(dir) // 0
console.log(Color[0]) // "Red"
console.log(Color[1]) // "Blue"

// String enums
enum Response {
  Yes = "YES",
  No = "NO"
}

const r: Response = Response.Yes
console.log(r) // "YES"

// Heterogeneous enums are discouraged, but allowed:
enum Mixed {
  A = 1,
  B = "two"
}

console.log(Mixed.A) // 1
console.log(Mixed.B) // "two"
```

`extends`: Used in classes and types to indicate inheritance or constraint.

```ts
class Square extends Shape {}

function f<T extends string>(value: T): T {
  return value
}
```

### Hoisting

In JavaScript, _hoisting_ means variable and function declarations are moved to the top of their containing scope during the compilation phase, before code execution.

The note "Hoisted; may lead to unexpected behavior," refers specifically to the `var` keyword. 
Unlike `let` and `const`, variables declared with `var` are hoisted to the top of their function scope and initialized with `undefined`. 
This allows you to reference them before their actual declaration line without causing a `ReferenceError`, but it often leads to confusing behavior:

```ts
function demo() {
  console.log(x) // undefined, not ReferenceError
  var x = 5
}
```

This happens because JavaScript rewrites the function internally like this:

```ts
function demo() {
  var x
  console.log(x) // undefined
  x = 5
}
```

So while the declaration is hoisted, the assignment remains in place, leading to potentially surprising results if you're not expecting it. 
This is one of the reasons why `let` and `const`, which are block-scoped and not initialized until the declaration line, are now the preferred way to declare variables.

## Flow Control

`if`, `else`

```ts
if (x > 0) {
  console.log("positive")
} else {
  console.log("non-positive")
}
```

`switch`, `case`, `default`

```ts
switch (status) {
  case "loading":
    console.log("Still loading")
    break
  case "done":
    console.log("All done!")
    break
  default:
    console.log("Unknown status")
}
```

The switch statement can be used with expressions that resolve to primitive values like numbers, strings, or enums. 
The value given in the switch expression is compared using strict equality (===) against each case. 
For example, string literals are common, but numeric codes or TypeScript enums can also be switched on. 
Complex types such as objects or arrays are not suitable for use in a switch, as they are not primitive and do not match by value.

`for`, `while`, `do`

```ts
for (let i = 0; i < 3; i++) {
  console.log(i)
}

let j = 0
while (j < 3) {
  console.log(j)
  j++
}

let k = 0
do {
  console.log(k)
  k++
} while (k < 3)
```

`break`, `continue`: control loop flow.

```ts
for (let i = 0; i < 5; i++) {
  if (i === 3) continue
  if (i === 4) break
  console.log(i)
}
// Output: 0 1 2
```

`try`, `catch`, `finally`, `throw`: for error handling.

```ts
try {
  throw new Error("Fail")
} catch (e) {
  console.error(e)
} finally {
  console.log("cleanup")
}
```

## Operators

Arithmetic: `+`, `-`, `*`, `/`, `%`, `**`

```ts
let sum = 3 + 2  // 5
let product = 4 * 5 // 20
```

Assignment: `=`, `+=`, `-=`, etc.

```ts
let x = 10
x += 5  // 15
```

Comparison: `==`, `===`, `!=`, `!==`, `<`, `>`, `<=`, `>=`

```ts
console.log(5 === "5") // false
console.log(5 == "5")  // true
```

Logical: `&&`, `||`, `!`, `??`

```ts
const a = true && false  // false
const b = undefined ?? "default"  // "default"
```

Bitwise: `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`

```ts
let result = 5 & 3  // 1
```

Ternary: `condition ? a : b`

```ts
const score = 75
const status = score > 50 ? "pass" : "fail"
```

Spread/rest: `...`

```ts
const arr = [1, 2, 3]
const newArr = [...arr, 4]

function sum(...args: number[]) {
  return args.reduce((a, b) => a + b, 0)
}
```

Destructuring:

```ts
const [a, b] = [1, 2]
const { x: xVal } = { x: 42 }
```

`typeof`, `instanceof`, `in`, `delete`, `void`

```ts
console.log(typeof "hello") // "string"
console.log([] instanceof Array) // true
const obj = { key: "value" }
console.log("key" in obj) // true
delete obj.key
console.log("key" in obj) // false
console.log(void 0) // undefined
```

## Special Keywords

`this`: Refers to the current object or execution context.

```ts
const obj = {
  name: "box",
  logThis() {
    console.log(this.name)
  }
}
obj.logThis() // "box"
```

`new`: Instantiates a class or constructor function.

```ts
class User {
  constructor(public name: string) {}
}
const u = new User("Sam")
```

`super`: Access the parent class.

```ts
class Animal {
  speak() {
    return "base sound"
  }
}
class Dog extends Animal {
  speak() {
    return super.speak() + " + bark"
  }
}
```

`yield`, `await`: Used for generators and async/await.

```ts
async function getData() {
  const res = await fetch("/api")
  return res.json()
}

function* idGen() {
  yield 1
  yield 2
}
```

TypeScript keywords: `as`, `is`, `satisfies`, `infer`

```ts
const val = "hi" as string

function isString(x: unknown): x is string {
  return typeof x === "string"
}

type Flatten<T> = T extends Array<infer U> ? U : T
```

  `keyof`, `typeof`

```ts
type Props = { x: number, y: number }
type Keys = keyof Props // "x" | "y"
const point = { x: 1, y: 2 }
type PointType = typeof point
```

The `keyof` operator extracts the keys of the `Props` type as a union of string literal types.
In this case, `Keys` becomes `"x" | "y"`.

The `typeof` operator, when used in a type context, extracts the type of the value `point`.
Here, `PointType` is equivalent to `{ x: number, y: number }`.

This combination of `keyof` and `typeof` is commonly used to infer the structure of existing objects for purposes such as generic utilities or dynamic key-based transformations.

`readonly`, `abstract`, `declare`, `private`, `protected`, `public`, `static`

```ts
abstract class Shape {
  abstract area(): number
}

class Rectangle extends Shape {
  constructor(private width: number, protected height: number) {
    super()
  }

  area(): number {
    return this.width * this.height
  }
  
  static kind = "rect"
  
  static describe(): string { 
      return `This is a ${this.kind}`
  }
}

const r = new Rectangle(5, 10)
console.log(r.area()) // 50
console.log(Rectangle.kind) // "rect"
console.log(Rectangle.describe()) // "This is a rect"
```

Static members belong to the class itself, not to instances. 
Access them via the class name, not an object.

## Built-in Global Functions

These are part of the global scope and do not require an import statement.
Their behavior may vary slightly between JavaScript environments (e.g., browsers vs. Node.js).

`parseInt`, `parseFloat`: Convert strings to numbers.

```ts
parseInt("42") // 42
parseFloat("3.14") // 3.14
```

`isNaN`, `isFinite`: Test number values.

```ts
isNaN(NaN) // true
isFinite(100) // true
```

`eval`: Executes a string of JavaScript code.

```ts
eval("2 + 2") // 4
```

`encodeURI`, `decodeURI`: Encode/decode a full URI.

```ts
encodeURI("https://example.com/?q=test value")
```

`encodeURIComponent`, `decodeURIComponent`: Encode/decode URI components.

```ts
encodeURIComponent("test value") // "test%20value"
```

`setTimeout`, `setInterval`, `clearTimeout`, `clearInterval`: Timer functions.

```ts
const id = setTimeout(() => console.log("Hello"), 1000)
clearTimeout(id)
```

`alert`, `confirm`, `prompt`: Browser-specific user dialogs.

```ts
alert("Hello")
```

`console.log`, `console.error`, etc.: Logging functions.

```ts
console.log("Debug info")
console.error("Something went wrong")
```

## Built-in Global Values

These values are part of the global execution context and are always accessible. 
They represent common JavaScript primitives or constants, and are frequently used in type checks, math operations, or to represent exceptional states.

`undefined`: A variable that has been declared but not assigned a value.

```ts
let x
console.log(x) // undefined
```

`null`: Represents the intentional absence of any value.

```ts
const value = null
```

`NaN`: Stands for "Not-a-Number", returned from invalid math operations.

```ts
console.log(0 / 0) // NaN
```

`Infinity` / `-Infinity`: Represent numeric infinity and negative infinity.

```ts
console.log(1 / 0) // Infinity
console.log(-1 / 0) // -Infinity
```

`globalThis`: Refers to the global object, regardless of environment (browser, Node, etc).

```ts
console.log(globalThis.Math === Math) // true
```

## Uses of Square Brackets `[]`

Square brackets have several distinct uses in JavaScript and TypeScript:

### Array Literals

To create arrays.

```ts
const nums = [1, 2, 3]
```

### Array Indexing

To access array elements by index.

```ts
console.log(nums[0]) // 1
```

### Property Access (Computed)

To access object properties via strings or variables.

```ts
const key = "name"
const person = { name: "Alice" }
console.log(person[key]) // "Alice"
```

### Dynamic Assignment

To dynamically add or update properties.

```ts
person["age"] = 30
```

### Destructuring Arrays

Used on the left-hand side of assignments.

```ts
const [first, second] = [10, 20]
```

### Index Signatures (TypeScript)

Defines dynamic property keys (Described in detail later in the book).

```ts
type Dictionary = {
  [key: string]: number
}
```

### Mapped Types (TypeScript)

To create new types by mapping over keys (Described in detail later in the book).

```ts
type Options = {
  [K in "yes" | "no"]: boolean
}
```

### Tuples

Typed fixed-length arrays.

```ts
type Point = [number, number]
const origin: Point = [0, 0]
```

### Nested Access

Accessing elements of nested structures.

```ts
const matrix = [[1, 2], [3, 4]]
console.log(matrix[1][0]) // 3
```

Square brackets are versatile and context-dependent, playing roles in both runtime behavior (e.g., indexing) and type declarations (e.g., mapped types) in TypeScript.
