# The JavaScript Object Model

Understanding the JavaScript object model, including prototypes, constructors, and class syntax, 
is essential for working fluently with both JavaScript and TypeScript.

JavaScript uses a _prototype-based_ object model. 
Unlike class-based languages, where classes define inheritance, JavaScript objects inherit from other objects directly. 
This design supports powerful but sometimes non-intuitive behaviors.

## Objects Are Key-Value Maps

In JavaScript, all non-primitive values are objects. 
Objects are collections of properties (keys and values) and can have methods (functions as values).

```ts
// Method shorthand (ES6)
const person1 = {
  name: "Alice",
  greet() {
    // 'this' refers to the 'person1' object:
    return `Hello, I'm ${this.name}` 
  }
}
console.log(person1.greet()) // Hello, I'm Alice

// Traditional function property
const person2 = {
  name: "Bob",
  greet: function () {
    return `Hello, I'm ${this.name}`
  }
}
console.log(person2.greet()) // Hello, I'm Bob

// Arrow function (not recommended for methods)
const person3 = {
  name: "Charlie",
  greet: () => `Hello, I'm ${this?.name}`
}
console.log(person3.greet()) // Hello, I'm undefined
```

This shows the three ways to define methods inside an object:

* **Method shorthand**: The preferred and concise ES6 syntax.
* **Traditional function property**: Fully explicit and works identically.
* **Arrow function**: Inherits `this` from the surrounding context, which is usually not what you want in object methods.

## Prototypes and Inheritance

Every function in JavaScript has a prototype object. 
When you use a function as a constructor (via `new`), the resulting object's prototype is set to that function’s prototype.
You can assign shared methods or data to this prototype:

```ts
function Car(make, model) {
    this.make = make
    this.model = model
}

// Add a shared method
Car.prototype.describe = function () {
    return `${this.make} ${this.model}`
}

// Add a shared property
Car.prototype.category = "vehicle"

const c1 = new Car("Toyota", "Camry")
const c2 = new Car("Honda", "Civic")

console.log(c1.describe())  // Toyota Camry
console.log(c2.category)    // vehicle
```

By assigning `Car.prototype.describe`, you are declaring a method on all instances created using `new Car(...)`.

In JavaScript, method names like `describe` are not required to follow any naming convention.
They’re just regular property names. 
However, developers often adopt informal naming conventions to make code easier to understand.

The name `describe` is a common convention. 
It implies that the method returns a human-readable description of the object. 
Other similar convention-based names might include:

- `toString()`: Return a string representation
- `describe()`: Provide a descriptive summary
- `equals(other)`: Compare with another instance
- `clone()`: Return a shallow or deep copy
- `reset()`: Restore default state
- `initialize()`: One-time setup after construction

These names aren't enforced by JavaScript but are part of conventional usage patterns shared across libraries and frameworks.

### The Internal `[[Prototype]]` Link

The double square brackets `[[Prototype]]` indicate an internal property of JavaScript objects.
This is not something you can access or manipulate directly in code using normal property access (like `obj.[[Prototype]]`).
Instead, it's a specification-level term used in the ECMAScript standard to describe the internal linkage between objects.

Each object in JavaScript has an internal `[[Prototype]]` link to another object. 
This forms a prototype chain used for property lookup.

```ts
const animal = {
  sound: "generic noise",
  speak() {
    return this.sound
  }
}

const dog = Object.create(animal)
dog.sound = "woof"
console.log(dog.speak()) // woof
```

If `speak` were not found on `dog`, JavaScript would follow `dog.__proto__` to `animal` to find it.

### Reading and Modifying `[[Prototype]]`

In practice, you can interact with an object's prototype using `Object.getPrototypeOf(obj)` or `Object.setPrototypeOf(obj, proto)`.
In many environments, the special accessor `__proto__` also lets you view or change the prototype, though it's considered legacy.
Avoid using __proto__ in production code. Use the standard functions instead:

```ts
Object.setPrototypeOf(obj, newProto)
Object.getPrototypeOf(obj)
```

So `[[Prototype]]` is just the formal name for the internal linkage that underlies JavaScript's prototype-based inheritance.

You cannot use `Object.setPrototypeOf(obj, proto)` to add arbitrary attributes to an object.
`Object.setPrototypeOf` sets the internal `[[Prototype]]` of `obj` to `proto`. 
This means `obj` will inherit properties and methods from `proto`, but it doesn't copy any properties directly to `obj`.

```ts
const proto = { greeting: "hello" }
const obj = {}

Object.setPrototypeOf(obj, proto)

// Inherited via prototype:
console.log(obj.greeting) // "hello" 
// Not a direct property:
console.log(obj.hasOwnProperty("greeting")) // false
```

Any properties on the prototype will appear accessible on `obj` through the prototype chain, but they are not stored on `obj` itself.

You cannot do something like this:

```ts
setPrototypeOf(child, 42)
```

and expect it to work as if you’re assigning a new top-level property. 
You're modifying the prototype object itself, which could be valid, but that’s a separate object, not the child directly.

### Additional prototype methods:

- `Object.create(proto)`: Creates a new object with its internal prototype set to proto.

```ts
const base = { greet: () => "hello" }
const child = Object.create(base)
console.log(child.greet()) // "hello"
```

- `Object.prototype.isPrototypeOf(obj)`: Checks whether the object appears in the prototype chain of obj.

```ts
const parent = {}
const child = Object.create(parent)
console.log(parent.isPrototypeOf(child)) // true
```

- `obj.hasOwnProperty(prop)`:  Returns true if the property exists directly on the object (not via the prototype chain).

```ts
const obj = Object.create({ inherited: true })
obj.own = true
console.log(obj.hasOwnProperty("own")) // true
console.log(obj.hasOwnProperty("inherited")) // false
```

- `Object.getOwnPropertyDescriptors(obj)`: Returns all property descriptors for an object’s own (non-inherited) properties. 
  Helpful for understanding how inheritance and property attributes behave.

Yes, there are several additional important details and best practices to understand about prototypes in JavaScript that would round out this chapter well. Here are suggestions for a new subsection you could append to the chapter:

### Prototypes Are Live

If you modify a prototype object after it’s been assigned, the change affects all objects that inherit from it.

```ts
const base = {}
const child = Object.create(base)

base.greet = () => "hello"
console.log(child.greet()) // "hello"
```

This dynamic nature means modifying prototypes can have wide-reaching effects and should be done with caution.

### Prototype Chain Depth

The prototype chain eventually terminates at `Object.prototype`, whose prototype is `null`.

```ts
const obj = {}
console.log(Object.getPrototypeOf(obj)) // Object.prototype
console.log(Object.getPrototypeOf(Object.prototype)) // null
```

You can use this knowledge to perform safe prototype traversal or detect objects with no prototype (via `Object.create(null)`).

### `Object.create(null)`

You can create a "bare" object with no prototype:

```ts
const dict = Object.create(null)
dict.key = "value"
console.log(dict.toString) // undefined: not inherited
```

This is useful for dictionary-like objects where you want to avoid conflicts with inherited keys like `toString`.

### Performance Considerations

Modifying the prototype of an existing object (e.g., with `Object.setPrototypeOf`) 
is slower than creating it with the desired prototype from the start (`Object.create`). 
If you're writing performance-critical code, avoid changing prototypes dynamically.

## Constructor Functions

Before `class` syntax was introduced in ES6, constructor functions were the primary way to create object blueprints:

```ts
function Car(make, model) {
  this.make = make
  this.model = model
}

Car.prototype.describe = function () {
  return `${this.make} ${this.model}`
}

const c = new Car("Toyota", "Camry")
console.log(c.describe()) // Toyota Camry
```

Using `new` sets the prototype of the constructed object to `Car.prototype`.



## Class Syntax

ES6 introduced the `class` keyword as a more familiar way to declare constructors and prototypes, 
especially for developers coming from class-based languages like Java, C#, or C++.

```ts
class Shape {
  constructor(public name: string) {}
  describe() {
    return `This is a ${this.name}`
  }
}

const s = new Shape("circle")
console.log(s.describe()) // This is a circle
```

Under the hood, `class` still uses prototypes and constructor functions.



## Inheritance with Classes

You can use `extends` to set up prototype-based inheritance between classes.

```ts
class Animal {
  speak() {
    return "noise"
  }
}

class Dog extends Animal {
  speak() {
    return super.speak() + " woof"
  }
}

const d = new Dog()
console.log(d.speak()) // noise woof
```



## `this` and Method Binding

`this` always refers to the caller’s context. When passing methods around, you may lose the binding.

```ts
const user = {
  name: "Sam",
  greet() {
    return `Hello, ${this.name}`
  }
}

const greetRef = user.greet
console.log(greetRef()) // Hello, undefined
```

To fix this, bind the method:

```ts
const bound = user.greet.bind(user)
console.log(bound()) // Hello, Sam
```



## Dynamic Modification

You can add or modify properties at runtime:

```ts
const book = {}
book.title = "1984"
book.author = "George Orwell"
console.log(book)
```

You can also delete properties:

```ts
delete book.author
```



## Object Utility Functions

* `Object.create(proto)`  Creates a new object with the specified prototype.
* `Object.assign(target, source)`  Copies properties from source to target.
* `Object.entries(obj)`  Returns key-value pairs.
* `Object.keys(obj)`  Returns keys.
* `Object.values(obj)`  Returns values.

```ts
const o = { a: 1, b: 2 }
console.log(Object.entries(o)) // [['a', 1], ['b', 2]]
```



## Modern Class Fields

You can define fields directly on class instances:

```ts
class Counter {
  count = 0
  increment() {
    this.count++
  }
}
```

These are added to the instance, not the prototype.



