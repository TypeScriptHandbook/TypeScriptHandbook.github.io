# Preface

This book is for developers who have a firm grasp of two or more programming languages, but not JavaScript or TypeScript.
The goal is to quickly give the experienced programmer a tour of the language,
including all the odd and obscure bits so you aren't flummoxed when you see them in practice.

Because you know two or more languages, you've seen similarities and differences between languages.
From experience, you know the concepts and what to expect from a language, you just don't know the details of how TypeScript does it.

I used ChatGPT and Claude as much as possible to write this book.
I started with the book's structure and chapter outlines, generated each chapter one at a time, then asked for clarifications, reorganized, and edited.
It was a lot easier than without an LLM, and to be honest, it would have seemed too big and distracting without that help.
However, it still took effort, editing, reviewing, and LLM coaching.

## Inception

Bill Frasure, James Ward and I worked for four years on _Effect Oriented Programming_, and we're still trying to figure out how to explain those concepts clearly.
When the team working on the TypeScript Effect library reached out and asked that we translate the book to this new language and library, we hesitated.
None of us knew TypeScript (TS), and although the Effect library is based on ZEO (which we used in the book), 
there were a lot of foreign ideas in the language and library.
JavaScript (JS) has a ... checkered past, and TypeScript is a compromise language to make transition easier for JavaScript programmers.
Because of this, we acknowledged (at least I think we did) that the learning curve would be bigger than we might expect.

JS/TS has a syntax that, upon first glance, looks familiar enough that we thought we could cargo-cult our way through.
But as I started working into the Effect docs, I found them casually using features that were really quite puzzling.
After delving into a few of these, I had a _we're-not-in-Kansas-anymore_ moment (from Wizard of Oz).
I realized we needed to actually learn this language in depth.

I wondered if I could herd ChatGPT into creating the book that the three of us needed.
If I could get that acceleration from an LLM, I might as well start and see how it goes.
After I started, I remembered that writing a book is a very effective way for me to learn a language.

## Outline

### Chapter 1: Context and Philosophy

- JavaScript: The TypeScript Substrate
- Why TypeScript?
  - The Rise of TypeScript
  - Early Design Goals
  - Influences and Inspirations
  - Widespread Adoption
- Structural Typing vs. Nominal Typing
  - The Benefits of Structural Typing
  - The Pitfalls of Structural Typing
  - Mental Models for Navigating TypeScript's System

### Chapter 2: Types, Literals, and Primitives

- Primitive Types
- Special Types
  - `any`
  - `unknown`
  - `void`
  - `never`
- Literal Types
- Template Literal Types
- Type Inference
- Template Literal Types
  - Inference in Function Parameters
  - Interpolation with Union Types

### Chapter 3: Keywords and Operators

- Declarations and Scope
  - Hoisting
- Flow Control
- Operators
- Special Keywords
- Built-in Global Functions
- Built-in Global Values
- Uses of Square Brackets `[]`
  - Array Literals
  - Array Indexing
  - Property Access (Computed)
  - Dynamic Assignment
  - Destructuring Arrays
  - Index Signatures (TypeScript)
  - Mapped Types (TypeScript)
  - Tuples
  - Nested Access

### Chapter 4: The JavaScript Object Model

- Object Fundamentals
  - Objects Are Key-Value Maps
  - Dynamic Modification
  - Object Utility Functions
  - `this` and Method Binding
- The Prototype System
  - Constructor Functions
    - What `new` Does
    - Any Function Can Be a Constructor
    - Return Values in Constructors
  - The Prototype Property
    - When Does a Function Get a Prototype?
    - The Constructor Property
    - Adding Methods to the Prototype
    - Prototype Properties Are Live
    - Common Mistake: Adding to Instance Instead of Prototype
    - Replacing the Entire Prototype
  - Prototype Chain and Inheritance
    - Basic Inheritance Example
    - Understanding the Prototype Chain
    - Method Resolution and Overriding
    - Accessing Parent Methods
    - The Internal `[[Prototype]]` Link
    - Creating Objects with Specific Prototypes
    - Prototype Chain Termination
- Modern JavaScript Classes
  - Basic Class Declaration
  - Class vs Constructor Function Equivalence
  - Class Fields
  - Class Inheritance with `extends`
  - Using `super` to Access Parent Methods
  - Classes Enforce Constructor Usage
  - Static Methods
  - Benefits of Class Syntax
  - TypeScript Class Enhancements
- Advanced Techniques
  - Static Factory Methods
  - `Object.defineProperty` for Fine-Grained Control
  - Proxy-Based Objects
  - Singleton Pattern with Module Closure
  - Symbol-Based Private Methods
  - Object Reconstruction from JSON
  - Mixin Pattern
  - When to Use These Patterns
- Key Concepts

### Chapter 5: Functions and Signatures

- Function Declarations vs Expressions
- Parameters
  - Optional Parameters
  - Default Parameters
  - Rest Parameters
- Function Types
- Overloads
- `this` in Functions
- `void` vs `undefined`

### Chapter 6: Objects, Interfaces, and Type Aliases

- Describing Object Shapes
- Initializing Class Instances
  - Using Static Factory Methods
  - Dependency Injection
- Access Modifiers
- Inheritance
- Abstract Classes
- Types vs Interfaces
- Extending Types
- Optional and Readonly Properties
- Index Signatures
- Excess Property Checks

### Chapter 7: Arrays, Tuples, and Readonly Types

- Arrays
- Tuples
- Readonly Arrays and Tuples

### Chapter 8: Enums and Const Assertions

- Numeric Enums
- String Enums
- Const Enums
- Literal Inference with `as const`
- Enum-Like Alternatives Using Mapped Types
  - 1. Union of String Literals + Object Mapping
  - 2. Const Object with `as const`
  - 3. Mapped Type-Based Enum Simulation
  - Generic Enum Builder

### Chapter 9: Type Inference and Control

- Basic Inference
- Type Narrowing
- Contextual Typing

### Chapter 10: Union and Intersection Types

- Basics
- Discriminated Unions
- Exhaustiveness Checks
- Intersection Types
- Common Mistakes and Clarity Techniques

### Chapter 11: Generics

- Generic Functions and Types
- Constraint-Based Design
- Type Defaults and Inference Quirks
- Variance
  - Covariance
  - Contravariance
  - Bivariance and Invariance
  - Variance Annotations

### Chapter 12: Type Transformations

- Conditional Types
  - Using `infer` to Extract Types
  - Recursive Conditional Types
- Template Literal Types
- `keyof` and Indexed Access Types
- `typeof` and `as const`
- Mapped Types
  - Predefined Mapped Types
- Key Remapping and Filtering
- Template Literal Types with Mapped Types
- Conditional Logic in Mapped Types
