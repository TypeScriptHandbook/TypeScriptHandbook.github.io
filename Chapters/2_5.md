# Enums and Const Assertions

Use enums to define a fixed set of named constants, either numeric or string-based.
TypeScript supports enumerated types (enums) to define a set of named constants. 
Numbers and strings are the only two value types allowed; TypeScript enums cannot contain booleans, objects, or other complex types. 
Additionally, `as const` assertions allow precise inference of literal types.

## Numeric Enums

By default, enums are numeric, starting from 0:

```ts
enum Direction {
  Up,
  Down,
  Left,
  Right
}

const move = Direction.Left
console.log(move) // 2
```

You can override the starting value or assign specific numbers:

```ts
enum Status {
  Ready = 1,
  Waiting = 3,
  Finished = 5
}
```

## String Enums

String enums require an explicit initializer:

```ts
enum Response {
  Yes = "YES",
  No = "NO"
}

const reply = Response.Yes
console.log(reply) // "YES"
```

## Const Enums

Use `const enum` for performance.
Values are inlined and there's no emitted object:

```ts
const enum Color {
  Red,
  Green,
  Blue
}

const c = Color.Green // Inlined as `1`
```

Const enums are erased at runtime, which improves efficiency but removes runtime access to enum metadata.

## Literal Inference with `as const`

You first saw `as const` used to preserve array and tuple types in Chapter 2.4. Here, we extend that idea to enable union type inference.

Use `as const` to preserve exact literal values:

```ts
const ROLES = ["admin", "user", "guest"] as const
```

Without `as const`, the array is inferred as `string[]`. With it, TypeScript infers the type as `readonly ["admin", "user", "guest"]`.

You can use it to create a union type:

```ts
type Role = typeof ROLES[number]
```

This is equivalent to:

```ts
type Role = "admin" | "user" | "guest"
```

This pattern is preferred over enums when you want exhaustive string-based typing without the enum overhead.
Use `as const` and `typeof` for lightweight, literal unionsâ€”especially in modern codebases that avoid traditional enums.
