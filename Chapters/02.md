# Types, Literals, and Primitives

TypeScript introduces a type system over JavaScript's runtime behavior. 
At the lowest level, this system includes _primitive types_, _literal types_, 
and a few special categories designed to model uncertainty or impossibility.

## Primitive Types

TypeScript types mirror JavaScript’s runtime types.
You can use `typeof` at runtime to verify most of them (except `null`, which confusingly returns "object").

The basic types are the familiar runtime primitives of JavaScript:

```ts
let str: string = "hello"
let num: number = 42
let bool: boolean = true
let big: bigint = 123n
let sym: symbol = Symbol("s")
let undef: undefined = undefined
let nul: null = null
```

The `bigint` type allows you to represent arbitrarily large integers, beyond the safe integer limits of JavaScript's `number` type. 
You create them by appending `n` to the end of an integer literal, like `123n`.

The `symbol` type represents unique, opaque values that can be used as property keys or internal identifiers. 
Even two symbols with the same description are not equal.

The `undefined` type is a special primitive that usually indicates the absence of a value or uninitialized state. 
It's the default value for uninitialized variables and missing function returns.

The `null` type represents an intentional absence of any value. 
It’s often used explicitly to clear values or as a default. 
Unlike `undefined`, which often arises from language mechanics, `null` is generally assigned intentionally by the developer.

## Special Types

### `any`

The "escape hatch" of the type system. Disables type checking and inference:

```ts
let value: any = 123
value.toUpperCase() // no error, even if wrong
```

Use sparingly and deliberately.

### `unknown`

Like `any`, but safe. You can assign anything to `unknown`, but must narrow it before usage:

```ts
let input: unknown = getValue()

if (typeof input === "string") {
  console.log(input.toUpperCase())
}
```

### `void`

Signals the absence of a return value:

```ts
function log(message: string): void {
  console.log(message)
}
```

### `never`

Represents values that never occur:

```ts
function fail(): never {
  throw new Error("fail")
}
```

Also used in exhaustive checks with `switch` and `match`.

## Literal Types

You can narrow a type to an exact value, limiting assignment to only those literal values:

```ts
let direction: "left" | "right" | "center" = "left"
```

This means `direction` can only ever hold the values "left," "right," or "center," but nothing else. 
The type of `direction` is a new _union type_ composed of three specific string literals. 
It is not equivalent to the broader `string` type. Instead, it forms a restricted subset of `string` values that the variable is allowed to take. This enables precise control over valid values and improves type safety by rejecting unintended strings at compile time. This narrowing is enforced by the compiler and is extremely useful when designing types that reflect fixed sets of options.

If you're familiar with enumerations (enums) from other languages, you can think of literal union types as a lightweight alternative. Both define a finite set of valid values, but enums introduce new named identifiers, while literal types work directly with string, number, or boolean values. Enums can offer better readability and runtime presence, but literal types are often more flexible, simpler to declare, and integrate seamlessly with TypeScript's type system. For many cases where the values themselves are meaningful (like "left" or "center"), literal types are more idiomatic in TypeScript.

Literal types are foundational in defining _discriminated unions_, a powerful pattern for modeling variant data structures. These types allow you to distinguish between alternatives by assigning each variant a unique literal tag:

```ts
type Success = { status: "ok"; data: string }
type Failure = { status: "error"; message: string }
type Result = Success | Failure
```

Here, the `status` field acts as a discriminant. The compiler uses it to narrow the type within a control flow:

```ts
function handle(result: Result) {
  if (result.status === "ok") {
    console.log(result.data) // TypeScript knows this is Success
  } else {
    console.error(result.message) // TypeScript knows this is Failure
  }
}
```

Literal types are supported for:

* strings: "start", "stop", "pause"
* numbers: 0, 1, 42
* booleans: `true`, `false`

They can also be used in combination with template literal types and conditional types to model string patterns or value constraints at the type level.

Keep in mind that when you declare a variable with `const`, TypeScript retains the literal type:

```ts
const mode = "dark" // type is "dark"
```

Whereas with `let`, the type generalizes:

```ts
let mode = "dark" // type is string
```

This makes `const` declarations especially important when working with literal unions and discriminants.

## Template Literal Types

TypeScript lets you form new types from string literals:

```ts
type ID = `user-${number}`
```

These types are checked statically and support interpolation and inference.

## Type Inference

You often don't need to annotate types:

```ts
const count = 5 // inferred as number
```

But be aware of how inference generalizes:

```ts
const mood = "happy"       // inferred as "happy"
let status = "loading"     // inferred as string
```

This distinction arises because `const` implies immutability. When a literal is assigned to a `const`, TypeScript preserves the specific literal type (e.g., `"happy"`). But when using `let`, the compiler assumes the variable may change and generalizes the type (e.g., `string`).

This behavior is essential when working with discriminated unions or literal union types. If you want to preserve a specific value as a type-level discriminant, always use `const` to prevent generalization.
