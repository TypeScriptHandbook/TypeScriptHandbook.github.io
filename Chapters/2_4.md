# Arrays, Tuples, and Readonly Types

TypeScript provides precise typing for indexed collections through arrays and tuples. You can also mark arrays and their elements as `readonly` to prevent mutation.

## Arrays

An array of values of a single type is written using either of the equivalent forms `type[]` or `Array<type>`:

```ts
const scores: number[] = [85, 92, 78]
const names: Array<string> = ["Alice", "Bob", "Carol"]
```

You can perform common array operations just as in JavaScript:

```ts
names[0]                      // access by index
names.push("Carol")          // add to the end
const last = names.pop()      // remove last item
names.unshift("Zoe")         // add to the beginning
const first = names.shift()   // remove first item

names.forEach((name) => console.log(name))  // iterate with forEach
```

You can also use loops like `for...of`, `forEach`, or methods like `map` to transform arrays. For example:

```ts
const upper: string[] = names.map((n: string): string => n.toUpperCase())
console.log(upper) // ["ALICE", "BOB", "CAROL"]

const filtered: string[] = names.filter((n: string): boolean => n.startsWith("A"))
console.log(filtered) // ["Alice"]

const summary: number = scores.reduce((sum: number, score: number): number => sum + score, 0)
console.log(summary) // 255

const report: string = names
  .map((name: string, i: number): string => `${i + 1}. ${name}`)
  .sort()
  .slice(0, 2)
  .join("
") // join lines into a single string

console.log(report)
// 1. Alice
// 2. Bob
// 3. Carol

const flattened = names.flatMap((name) => name.split(""))
console.log(flattened) // e.g., ['A', 'l', 'i', 'c', 'e', 'B', 'o', 'b']

const found = names.find((name) => name.length > 3)
console.log(found) // e.g., "Alice"

function isShortName(value: string): value is string {
  return value.length <= 3
}

const shortNames = names.filter(isShortName)
console.log(shortNames) // e.g., ["Bob"]

const hasShort = names.some(isShortName)
console.log(hasShort) // true if any name is short

const allShort = names.every(isShortName)
console.log(allShort) // true if all names are short

const sorted = [...names].sort((a, b) => a.localeCompare(b))
console.log(sorted) // alphabetically sorted copy

// Traverse the array with a for...of loop:
for (const name of names) {
  console.log(name.toUpperCase())
}
```

Arrays are homogeneous by default. To mix types, use unions:

```ts
const values: (string | number)[] = ["high", 1, "low", 2]
```

## Tuples

Tuples are fixed-length, ordered sequences where each element may have a different type. You can optionally label tuple elements to improve clarity in tooling and documentation:

```ts
type RGB = [red: number, green: number, blue: number]
const color: RGB = [255, 128, 0]
```

These labels are not enforced at runtime but enhance readability and editor support. Tuples are especially useful when combining structured values with function parameters:

```ts
function printPair([x, y]: [number, number]) {
  console.log(`(${x}, ${y})`)
}

printPair([3, 4])
```

You can also destructure tuples assigned to object properties:

```ts
type LabeledPair = { label: string; coords: [number, number] }
const point: LabeledPair = { label: "origin", coords: [0, 0] }
const [x, y] = point.coords
```

Tuples preserve position-based meaning and are useful when the structure is known and consistent. where each element may have a different type.

```ts
const entry: [string, number] = ["age", 42]
```

You can destructure tuples:

```ts
const [label, value] = entry
```

Tuples preserve position-based meaning and are useful when the structure is known and consistent. For example:

```ts
type RGB = [number, number, number]
const color: RGB = [255, 128, 0]
```

You can specify optional tuple elements, but they must trail required elements:

```ts
type Response = [string, number?]
const res1: Response = ["OK"]
const res2: Response = ["Created", 201]
```

## Readonly Arrays and Tuples

To make an array immutable, prefix it with `readonly`, or use the `as const` assertion to deeply freeze an entire literal structure. You can also pass `readonly` arrays into functions to ensure they aren't mutated:

```ts
const keywords: readonly string[] = ["async", "await"]

const locked = ["on", "off"] as const
// locked has type: readonly ["on", "off"]

const response = { status: "OK", code: 200 } as const
// response.status is type "OK", not string
// response.code is type 200, not number

function logKeywords(values: readonly string[]) {
  values.forEach(console.log)
  // values.push("new") // Error: cannot modify a readonly array
}

logKeywords(keywords)
```

You can also apply `as const` to tuples:

```ts
const rgb = [0, 0, 0] as const
console.log(rgb) // [0, 0, 0]
```

This ensures the array or tuple cannot be changed (e.g., no `push`, `pop`, or item assignment)., prefix it with `readonly`, or use the `as const` assertion to deeply freeze an entire literal structure:

```ts
const keywords: readonly string[] = ["async", "await"]

const locked = ["on", "off"] as const
// locked has type: readonly ["on", "off"]

const response = { status: "OK", code: 200 } as const
// response.status is type "OK", not string
// response.code is type 200, not number
```

For tuples:

```ts
const rgb: readonly [number, number, number] = [0, 0, 0]
```

This ensures the array or tuple cannot be changed (e.g., no `push`, `pop`, or item assignment).

You can also use the `ReadonlyArray<T>` type:

```ts
function printAll(items: ReadonlyArray<string>) {
  for (const item of items) console.log(item)
}
```
