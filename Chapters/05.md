# Functions and Signatures

In TypeScript, functions are first-class values with precisely described input and output types. Type signatures are not just documentation—they are checked by the compiler, helping prevent errors and clarify intent.

## Function Declarations vs Expressions

Functions can be declared:

```ts
function greet(name: string): string {
  return `Hello, ${name}!`
}
```

Or defined as expressions (also called "lambdas" or "arrow functions"):

```ts
const greet = (name: string): string => `Hello, ${name}!`
```

Both forms are fully typed and can be passed around, assigned to variables, and used as arguments. Function expressions are often more convenient in contexts where you want to define functions inline or use them as values, whereas declarations are hoisted and more readable for top-level definitions.

## Parameters

TypeScript supports all common parameter features:

### Optional Parameters

```ts
function log(message: string, userId?: string) {
  console.log(message, userId)
}
```

The `?` makes `userId` optional and assigns `undefined` if omitted.

### Default Parameters

```ts
function greet(name = "Guest") {
  return `Hello, ${name}`
}
```

You can combine default parameters and type annotations:

```ts
function greet(name: string = "Guest") {
  return `Hello, ${name}`
}
```

### Rest Parameters

Rest parameters allow you to define functions that accept any number of arguments, collected into an array. This is useful for variadic functions:

```ts
function sum(...values: number[]): number {
  return values.reduce((a, b) => a + b, 0)
}
```

You can also use rest parameters alongside regular parameters (with the important caveats that there can only be one rest parameter, and it must be the final one):

```ts
function logLevels(level: string, ...messages: string[]) {
  console.log(`[${level}]`, ...messages)
}

logLevels("INFO", "Start", "Processing", "Done")
// Output: [INFO] Start Processing Done
```

The type `string[]` on `...messages` ensures that all remaining arguments are strings.

```ts
function sum(...values: number[]): number {
  return values.reduce((a, b) => a + b, 0)
}
```

The type `number[]` ensures all rest arguments are numbers.

## Function Types

Function types can be declared independently:

```ts
type Greet = (name: string) => string
```

You can then use this type to annotate variables or parameters:

```ts
const welcome: Greet = (name) => `Welcome, ${name}`
console.log(welcome("Alice")) // "Welcome, Alice"
```

Function types can also be declared inline:

```ts
const shout: (msg: string) => string = (msg) => msg.toUpperCase()
console.log(shout("hello")) // "HELLO"
```

## Overloads

You can declare multiple signatures for the same function:

```ts
function makeDate(timestamp: number): Date
function makeDate(year: number, month: number, day: number): Date
function makeDate(a: number, b?: number, c?: number): Date {
  return b !== undefined && c !== undefined
    ? new Date(a, b, c)
    : new Date(a)
}
```

Only the last implementation contains a body. The preceding signatures are overloads and serve only to guide the type system.

## `this` in Functions

In JavaScript and TypeScript, `this` is a special keyword that refers to the object context in which a function is called. Its meaning depends on how the function is invoked, not where it is defined. In traditional function declarations, `this` is dynamically bound based on the call site.

In TypeScript, you can explicitly annotate the type of `this` in a function using a special first parameter named `this`. This parameter does not represent a value passed at runtime; instead, it tells the compiler what shape the `this` context is expected to have when the function is invoked. At runtime, `this` is resolved by the call site just like in regular JavaScript, and is accessed inside the function body as it normally would be—via the `this` keyword:

```ts
function describe(this: { label: string }) {
  return `Label: ${this.label}`
}
```

This is particularly helpful when a function will be used as a method or needs a known calling context. It enables the compiler to type-check accesses to properties on `this`, preventing errors.

Note that arrow functions do not have their own `this`—they capture the `this` value from the surrounding lexical scope. This makes them ideal for callbacks or methods that need to preserve the outer context.

This helps TypeScript understand the calling context.

The `this` keyword is only valid inside function bodies. It cannot be used in arrow functions to declare a local `this`, nor can it be passed explicitly in code. Annotating `this` as a parameter allows the type checker to verify that the expected calling context will be respected, especially in object-oriented patterns or event handlers.. It cannot be used in arrow functions to declare a local `this`, nor can it be passed explicitly in code. Annotating `this` as a parameter allows the type checker to verify that the expected calling context will be respected, especially in object-oriented patterns or event handlers.

## `void` vs `undefined`

If a function returns nothing, annotate it with `void`, not `undefined`. 
The `void` type means the function *does not produce a value*, whereas `undefined` is a value of type `undefined`.
