# Objects, Interfaces, and Type Aliases

In TypeScript, objects are at the heart of the type system. You can describe their shape using interfaces or type aliases, and compose them with extensions, intersections, and constraints.

## Describing Object Shapes

Objects in TypeScript are defined by the names and types of their properties. While most object shapes are described using type annotations, you can also use classes to define objects with both structure and behavior. Classes are syntactic sugar over JavaScript's prototype-based inheritance, and are fully supported by TypeScript's type system.

Here is a standalone class:

```ts
class Point {
  // Constructor shorthand automatically defines and assigns fields
  constructor(public x: number, public y: number) {}
  toString(): string {
    return `(${this.x}, ${this.y})`
  }
}
```

TypeScript supports a convenient shorthand for defining and initializing class properties directly in the constructor parameters. 
By using `public`, `private`, or `protected` in front of the parameter names, TypeScript both declares and assigns them as instance fields.

## Initializing Class Instances

Once you define a class, you can create objects from it using the `new` keyword:

```ts
class User {
  constructor(public name: string, public age: number) {}
}

const u1 = new User("Alice", 30)
```

You can create instances without shorthand by assigning fields inside the constructor body:

```ts
class LegacyUser {
  name: string
  age: number
  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }
}

const u2 = new LegacyUser("Bob", 45)
```

For classes with optional or default parameters:

```ts
class Config {
  constructor(public env: string = "dev", public debug?: boolean) {}
}

const defaultConfig = new Config()
const prodConfig = new Config("prod", true)
```

You can initialize objects indirectly with factory functions:

```ts
function createPoint(x: number, y: number) {
  return new Point(x, y)
}

const p = createPoint(10, 20)
```

This approach can abstract away class details, allowing you to manage creation logic separately.

You can initialize fields directly when they are declared. 
This pattern is useful for providing default values without requiring constructor logic:

```ts
class Circle {
  radius = 1
}

const c = new Circle()
console.log(c.radius) // 1

c.radius = 2
console.log(c.radius) // 2
```

Here, the radius field is initialized to one at the time of instance creation. 
Note that you can override this value after construction.
This approach simplifies class definitions where default values are sufficient and no constructor parameters are needed.

### Using Static Factory Methods

Classes can include static methods that return an instance.
This is useful when you want multiple ways to construct a class or when creation logic involves additional steps.

```ts
class Logger {
  private constructor(public level: string) {}

  static createDebug(): Logger {
    return new Logger("debug")
  }

  static createInfo(): Logger {
    return new Logger("info")
  }
}

const debugLogger = Logger.createDebug()
```

### Dependency Injection

You can inject dependencies during construction, allowing you to pass in collaborators or configuration objects:

```ts
class Service {
  constructor(private fetcher: () => Promise<string>) {}

  async getData() {
    return await this.fetcher()
  }
}

const s = new Service(() => Promise.resolve("fetched data"))
s.getData().then(console.log) // "fetched data"
```

## Access Modifiers

Class fields can be marked with visibility modifiers:

* `public`: accessible from anywhere (default)
* `private`: accessible only within the class
* `protected`: accessible within the class and its subclasses

```ts
class SecretPoint {
  constructor(private x: number, private y: number) {}
  reveal(): string {
    return `(${this.x}, ${this.y})`
  }
}
```

## Inheritance

Classes can extend other classes using `extends`:

```ts
class Animal {
  constructor(public name: string) {}
  speak(): void {
    console.log(`${this.name} makes a sound.`)
  }
}

class Dog extends Animal {
  speak(): void {
    console.log(`${this.name} barks.`)
  }
}

// Upcasting and dynamic binding
const a: Animal = new Dog("Rover")
a.speak() // "Rover barks."
```

## Abstract Classes

You can define abstract classes to enforce a contract without providing full implementation:

```ts
abstract class Shape {
  constructor(public color: string) {}
  abstract area(): number
  describe(): string {
    return `A ${this.color} shape.`
  }
}

class Square extends Shape {
  constructor(color: string, public size: number) {
    super(color)
  }
  area(): number {
    return this.size * this.size
  }
}
```

Abstract classes cannot be instantiated directly and may include both concrete and abstract members.

Classes can also implement interfaces:

```ts
interface Printable {
  toString(): string
}

class NamedCoordinate implements Printable {
  constructor(public x: number, public y: number, public label: string) {}
  toString(): string {
    return `${this.label}: (${this.x}, ${this.y})`
  }
}
```

And classes can implement type aliases as long as the alias only describes an object shape:

```ts
type Movable = {
  move(dx: number, dy: number): void
}

class MovablePosition implements Movable {
  constructor(public x: number, public y: number) {}
  move(dx: number, dy: number) {
    this.x += dx
    this.y += dy
  }
}
```

```ts
type Position = {
  x: number
  y: number
}
```

You can then use this type for variables, function parameters, or return types:

```ts
function printPosition(pt: Position) {
  console.log(`(${pt.x}, ${pt.y})`)
}
```

## Types vs Interfaces

Both interfaces and types can describe object shapes:

```ts
interface Person {
  name: string
  age: number
}

type PersonAlias = {
  name: string
  age: number
}
```

For most purposes, they are interchangeable. Type aliases are more modern and flexible, often preferred in contemporary codebases due to their ability to represent complex structures like unions, intersections, and conditional types. Interfaces offer better support for declaration merging and may be more readable in large OOP-style APIs.

## Extending Types

You can build new types from existing ones using `extends` (for interfaces) or intersections (`&`) for type aliases:

```ts
interface ColoredPoint extends Position {
  color: string
}

const cp: ColoredPoint = { x: 1, y: 2, color: "red" }
```

```ts
type Shape = { kind: string }
type Circle = Shape & { radius: number }
```

## Optional and Readonly Properties

You can mark properties as optional using `?`, which means the property may be `undefined` or omitted entirely. When accessing an optional property, use conditional checks to ensure it is present before using it:

```ts
interface User {
  id: number
  name?: string
}

function greet(user: User) {
  if (user.name) {
    console.log(`Hello, ${user.name}`)
  } else {
    console.log("Hello, anonymous user")
  }
}
```

You can also use optional chaining (`?.`) to safely access nested optional properties:

```ts
const firstLetter = user.name?.[0] // undefined if name is missing
```

If you need a fallback value, combine it with the nullish coalescing operator (`??`):

```ts
const name = user.name ?? "Guest"
```

Use `readonly` to make a property immutable:

```ts
interface Config {
  readonly apiKey: string
}
```

## Index Signatures

To describe objects with dynamic keys—where you don't know all the property names ahead of time—you can use an index signature. This tells the compiler what type of values to expect for arbitrary keys of a given type:

```ts
interface Dictionary {
  [key: string]: number
}
```

This allows an object to accept any number of properties, as long as their keys are strings and their values are numbers:

```ts
const scores: Dictionary = {
  alice: 10,
  bob: 15,
  charlie: 8
}
```

Index signatures are useful for cases like:

* Lookup tables
* Sparse configuration objects
* Dictionaries keyed by user input

You can use other key types too. For example, to describe a numeric index (as with arrays):

```ts
interface NumberArray {
  [index: number]: number
}
```

Keep in mind that when using both explicitly defined properties and an index signature, all properties must be assignable to the index value type:

```ts
interface SafeConfig {
  mode: string
  [key: string]: string // OK: 'mode' is a string
}

interface UnsafeConfig {
  debug: boolean
  [key: string]: string // Error: 'debug' is boolean, not string
}
```

This constraint ensures consistency between specific properties and the general rule enforced by the index signature.

## Excess Property Checks

TypeScript performs stricter checks on object literals to catch typos and unintended extra properties. When you assign an object literal directly to a typed variable, TypeScript ensures that only the explicitly declared properties of the target type are present:

```ts
type Point = {
  x: number
  y: number
}
```

```ts
const p: Point = { x: 0, y: 0, z: 3 } // Error: object literal may only specify known properties
```

In this case, `z` is not part of the `Point` type, so TypeScript flags it as an error. This is called an *excess property check*, and it only occurs when assigning *object literals*. If the same object is first assigned to a variable, the check is skipped:

```ts
const obj = { x: 0, y: 0, z: 3 }
const p: Point = obj // OK: no excess property check
```

This design helps catch common mistakes when defining object literals while still allowing flexibility when working with intermediate values or external data sources. If you intend to allow additional properties, consider using index signatures or type assertions.
