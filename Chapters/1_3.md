# Structural Typing vs. Nominal Typing

Most statically typed languages in widespread use, such as Java, C#, C++, Swift, and Rust, are **nominally typed**. 
In such languages, type compatibility is based on **names** and **declarations**. 
If you want one type to substitute for another, you must explicitly declare that relationship, often through inheritance or interface implementation.

TypeScript, in contrast, uses **structural typing**, also known as *duck typing*. 
If a value has all the required properties and methods, it is considered compatible, regardless of where it came from or what it's named.

Consider the following:

```ts
type Point2D = { x: number; y: number }

function logPoint(p: Point2D) {
  console.log(`${p.x}, ${p.y}`)
}

const point = { x: 10, y: 20, z: 30 }
logPoint(point) // OK! `z` is just extra
```

Even though `point` has an extra `z` property, it's assignable to `Point2D` because it structurally satisfies the requirement.

## The Benefits of Structural Typing

* **Fewer Declarations**: You don't need to formally declare that a class or type implements an interface
* **Flexible API Design**: Callers don’t have to extend or import specific types
* **Interoperability**: Easier to integrate third-party code or JSON data

This makes TypeScript feel more "fluid" than other typed languages. In many cases, this is exactly what you want: minimal ceremony and easy composition.

## The Pitfalls of Structural Typing

The flexibility comes with tradeoffs:

* **Accidental Compatibility**: Two unrelated types with the same shape will be considered compatible
* **Lost Intent**: Without nominal boundaries, it’s harder to encode domain distinctions like `UserId` vs `ProductId`
* **Over-permissiveness**: Mistaken types may pass checks if they happen to match structurally

To mitigate these, developers often reach for *branding* techniques to create pseudo-nominal types.

```ts
type UserId = string & { readonly brand: unique symbol }
type ProductId = string & { readonly brand: unique symbol }
```

These types are no longer interchangeable, even though they are both `string` under the hood. The added "brand" serves as a phantom type to enforce distinction.

## Mental Models for Navigating TypeScript's System

* Think in terms of **shapes**, not class hierarchies
* Use **interfaces** or **type aliases** to describe the required structure, not lineage
* Reach for branding or discriminated unions when you need identity, not just structure

TypeScript's structural type system rewards flexibility and expressiveness but requires discipline. Understanding when to let types flow freely and when to enforce separation is key to writing robust TypeScript code.

If you approach TypeScript expecting nominal rigor, you may find its system too loose. If you embrace its structural nature while layering your own constraints where needed, you'll find it a powerful ally.
