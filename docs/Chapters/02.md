# Types, Literals, and Primitives

TypeScript introduces a type system over JavaScript's runtime behavior.
At the lowest level, this system includes _primitive types_, _literal types_,
and a few special categories designed to model uncertainty or impossibility.

## Primitive Types

TypeScript types mirror JavaScript's runtime types.
You can use `typeof` at runtime to verify most of them (except `null`, which confusingly returns "object").

The basic types are the familiar runtime primitives of JavaScript:

```ts
let str: string = "hello"
console.log(typeof str) // "string"

let num: number = 42
console.log(typeof num) // "number"

let bool: boolean = true
console.log(typeof bool) // "boolean"

let big: bigint = 123n
console.log(typeof big) // "bigint"

let sym: symbol = Symbol("s")
console.log(typeof sym) // "symbol"

let undef: undefined = undefined
console.log(typeof undef) // "undefined"

let nul: null = null
console.log(typeof nul) // "object" (confusing!)
```

The `bigint` type represents arbitrarily large integers, beyond the safe integer limits of JavaScript's `number` type.
You create them by appending `n` to the end of an integer literal, like `123n`.

The `symbol` type represents unique, opaque values that serve as property keys or internal identifiers.
Even two symbols with the same description are not equal.

The `undefined` type indicates the absence of a value or uninitialized state.
It provides the default value for uninitialized variables and missing function returns.

The `null` type represents an intentional absence of any value.
Developers use it explicitly to clear values or as a default.
Unlike `undefined`, which often arises from language mechanics, developers generally assign `null` intentionally.

## Special Types

### `any`

The "escape hatch" of the type system. Disables type checking and inference:

```ts
let value: any = 123
value.toUpperCase() // no error, even if wrong
```

Use sparingly and deliberately.

### `unknown`

Like `any`, but safe. You can assign anything to `unknown`, but must narrow it before usage:

```ts
let input: unknown = getValue()

if (typeof input === "string") {
  console.log(input.toUpperCase())
}
```

### `void`

Signals the absence of a return value:

```ts
function log(message: string): void {
  console.log(message)
}
```

### `never`

Represents values that never occur:

```ts
function fail(): never {
  throw new Error("fail")
}
```

Also used in exhaustive checks with `switch` and `match`.

## Literal Types

You can narrow a type to an exact value, limiting assignment to only those literal values:

```ts
let direction: "left" | "right" | "center" = "left"
```

This means `direction` can only ever hold the values "left," "right," or "center," but nothing else.
The type of `direction` becomes a new _union type_ composed of three specific string literals.
It differs from the broader `string` type. Instead, it forms a restricted subset of `string` values that the variable accepts. This enables precise control over valid values and improves type safety by rejecting unintended strings at compile time. The compiler enforces this narrowing and proves extremely useful when designing types that reflect fixed sets of options.

If you know enumerations (enums) from other languages, you can think of literal union types as a lightweight alternative. Both define a finite set of valid values, but enums introduce new named identifiers, while literal types work directly with string, number, or boolean values. Enums offer better readability and runtime presence, but literal types provide more flexibility, simpler declarations, and integrate seamlessly with TypeScript's type system. For many cases where the values themselves carry meaning (like "left" or "center"), literal types prove more idiomatic in TypeScript.

Literal types form the foundation of _discriminated unions_, a powerful pattern for modeling variant data structures. These types distinguish between alternatives by assigning each variant a unique literal tag:

```ts
type Success = { status: "ok"; data: string }
type Failure = { status: "error"; message: string }
type Result = Success | Failure
```

Here, the `status` field acts as a discriminant. The compiler uses it to narrow the type within the control flow:

```ts
function handle(result: Result) {
  if (result.status === "ok") {
    console.log(result.data) // TypeScript knows this is Success
  } else {
    console.error(result.message) // TypeScript knows this is Failure
  }
}
```

Literal types support:

* strings: `"start"`, `"stop"`, `"pause"`
* numbers: `0`, `1`, `42`
* booleans: `true`, `false`

You can combine them with template literal types and conditional types to model string patterns or value constraints at the type level.

Keep in mind that when you declare a variable with `const`, TypeScript retains the literal type:

```ts
const mode = "dark" // type is "dark"
```

With `let`, the type generalizes:

```ts
let mode = "dark" // type is string
```

This distinction arises because `const` implies immutability.
When you assign a literal to a `const`, TypeScript preserves the specific literal type (e.g., `"dark"`).
But when using `let`, the compiler assumes the variable may change and generalizes the type (e.g., `string`).

This behavior proves essential when working with discriminated unions or literal union types.
If you want to preserve a specific value as a type-level discriminant, always use `const` to prevent generalization.

## Type Inference

You often don't need to annotate types:

```ts
const count = 5 // inferred as number
```

But understand how inference generalizes:

```ts
const mood = "happy"       // inferred as "happy"
let status = "loading"     // inferred as string
```

This distinction arises because `const` implies immutability.
When you assign a literal to a `const`, TypeScript preserves the specific literal type (e.g., `"happy"`).
But when using `let`, the compiler assumes the variable may change and generalizes the type (e.g., `string`).

This behavior proves essential when working with discriminated unions or literal union types.
If you want to preserve a specific value as a type-level discriminant, always use `const` to prevent generalization.

## Template Literal Types

TypeScript lets you form new types from string literals using template syntax.
This proves particularly useful for describing patterned string values like tagged identifiers or URL patterns.

```ts
type ID = `user-${number}`
```

This defines a type `ID` that matches any string starting with `"user-"` followed by a number, such as `"user-1"` or `"user-42"`.
The compiler checks these types statically and enables powerful composition.

### Inference in Function Parameters

When you type a parameter using a template literal type,
TypeScript verifies that the passed string conforms exactly to the required pattern:

```ts
type ID = `user-${number}`

function getUserId(id: ID) {
  return id
}

getUserId("user-42")  // OK
getUserId("admin-42") // Error: Argument of type '"admin-42"' is not assignable to parameter of type 'ID'
```

In this example, TypeScript accepts `"user-42"` but rejects `"admin-42"` because it doesn't start with `"user-"`.

### Interpolation with Union Types

You can combine template literal types with union types to describe broader sets of valid strings. This proves useful when modeling roles, statuses, or tagged names:

```ts
type Role = "admin" | "editor"
type RoleId = `${Role}-${number}`

const editorId: RoleId = "editor-7"  // OK
const badId: RoleId = "user-5"       // Error: "user" is not assignable to type 'Role'
```

The `RoleId` type describes any string composed of one of the allowed roles, followed by a hyphen and a number.
This gives you a strongly typed, pattern-matching string without requiring manual runtime validation.

You can combine template literal types with other type operations to create sophisticated string manipulation at the type level:

```ts
type Prefix = "api" | "db"
type Resource = "user" | "product"
type Endpoint = `/${Prefix}/${Resource}`

const userApi: Endpoint = "/api/user"     // OK
const productDb: Endpoint = "/db/product" // OK
const invalid: Endpoint = "/web/order"    // Error
```

This pattern proves particularly powerful for modeling APIs, configuration keys, CSS class names, or any domain where string patterns need validation at compile time.