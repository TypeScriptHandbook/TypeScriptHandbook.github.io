# Types, Literals, and Primitives

TypeScript introduces a type system over JavaScript's runtime behavior.
At the lowest level, this system includes _primitive types_, _literal types_,
and a few special categories designed to model uncertainty or impossibility.

## Primitive Types

TypeScript types mirror JavaScript's runtime types.
You can use `typeof` at runtime to verify most of them (except `null`, which confusingly returns "object").

The basic types are the familiar runtime primitives of JavaScript:

```ts
let str: string = "hello"
console.log(typeof str) // "string"

let num: number = 42
console.log(typeof num) // "number"

let bool: boolean = true
console.log(typeof bool) // "boolean"

let big: bigint = 123n
console.log(typeof big) // "bigint"

let sym: symbol = Symbol("s")
console.log(typeof sym) // "symbol"

let undef: undefined = undefined
console.log(typeof undef) // "undefined"

let nul: null = null
console.log(typeof nul) // "object" (confusing!)
```

The `bigint` type represents arbitrarily large integers, beyond the safe integer limits of JavaScript's `number` type.
You create them by appending `n` to the end of an integer literal, like `123n`.

The `symbol` type represents unique, opaque values that serve as property keys or internal identifiers.
Even two symbols with the same description are not equal.

The `undefined` type indicates the absence of a value or uninitialized state.
It provides the default value for uninitialized variables and missing function returns.

The `null` type represents an intentional absence of any value.
Developers use it explicitly to clear values or as a default.
Unlike `undefined`, which often arises from language mechanics, developers generally assign `null` intentionally.

## Special Types

### `any`

The "escape hatch" of the type system. Disables type checking and inference:

```ts
let data: any = 123
data.toUpperCase() // no error, even if wrong
```

Use sparingly and deliberately.

### `unknown`

Like `any`, but safe. You can assign anything to `unknown`, but must narrow it before usage:

```ts
function getRandomValue(): unknown {
  return Math.random() > 0.5 ? "hello" : 42
}

let userInput: unknown = getRandomValue()

if (typeof userInput === "string") {
  console.log(userInput.toUpperCase())
}
```

### `void`

Signals the absence of a return value:

```ts
function displayMessage(message: string): void {
  console.log(message)
}
```

### `never`

Represents values that never occur:

```ts
function throwError(): never {
  throw new Error("fail")
}
```

Also used in exhaustive checks with `switch` and `match`.

## Literal Types

You can narrow a type to an exact value, limiting assignment to only those literal values:

```ts
let direction: "left" | "right" | "center" = "left"
```

This means `direction` can only ever hold the values "left," "right," or "center," but nothing else.
The type of `direction` becomes a new _union type_ composed of three specific string literals.
It differs from the broader `string` type. Instead, it forms a restricted subset of
`string` values that the variable accepts. This enables precise control over valid values and improves type safety by rejecting unintended strings at compile time. The compiler enforces this narrowing and proves extremely useful when designing types that reflect fixed sets of options.

If you know enumerations (enums) from other languages, you can think of literal union types as a lightweight alternative. Both define a finite set of valid values, but enums introduce new named identifiers, while literal types work directly with string, number, or boolean values. Enums offer better readability and runtime presence, but literal types provide more flexibility, simpler declarations, and integrate seamlessly with TypeScript's type system. For many cases where the values themselves carry meaning (like "left" or "center"), literal types prove more idiomatic in TypeScript.

Literal types form the foundation of _discriminated unions_, a powerful pattern for modeling variant data structures. These types distinguish between alternatives by assigning each variant a unique literal tag:

```ts
type SuccessResult = { status: "ok"; data: string }
type FailureResult = { status: "error"; message: string }
type ApiResult = SuccessResult | FailureResult

function handleApiResult(result: ApiResult) {
  if (result.status === "ok") {
    console.log(result.data) // TypeScript knows this is SuccessResult
  } else {
    console.error(result.message) // TypeScript knows this is FailureResult
  }
}
```

Here, the `status` field acts as a discriminant. The compiler uses it to narrow the type within control flow.

Literal types support:

* strings: "start", "stop", "pause"
* numbers: 0, 1, 42
* booleans: `true`, `false`

You can combine them with template literal types and conditional types to model string patterns or value constraints at the type level.

## `const`, `readonly`, and `as const`

Understanding the distinction between `const`, `readonly`, and `as const` is crucial for writing effective TypeScript code. While all three relate to immutability, they serve different purposes and operate at different levels:

- **`const`** creates immutable variable bindings and preserves literal types
- **`readonly`** prevents modification of object properties at the type level
- **`as const`** creates the most specific possible readonly types for complex values

Let's explore each in detail and understand when to use them.

## The `const` Keyword

The `const` keyword is a JavaScript feature that creates an immutable binding to a value. Once declared, a `const` variable cannot be reassigned:

```typescript
const message = "Hello, world!";
// message = "Goodbye!"; // Error: Cannot assign to 'message' because it is a const

const numbers = [1, 2, 3];
// numbers = [4, 5, 6]; // Error: Cannot assign to 'numbers' because it is a const
```

**Important**: `const` only prevents reassignment of the variable itself, not mutation of the value it holds:

```typescript
const user = { name: "Alice", age: 30 };
user.age = 31; // This is allowed - we're mutating the object, not reassigning it

const items = [1, 2, 3];
items.push(4); // This is allowed - we're mutating the array, not reassigning it
```

When you declare a variable with `const`, TypeScript retains the literal type:

```ts
const appTheme = "dark" // type is "dark"
```

With `let`, the type generalizes:

```ts
let pageTheme = "dark" // type is string
```

This distinction arises because `const` implies immutability.
When you assign a literal to a `const`, TypeScript preserves the specific literal type (e.g., `"dark"`).
But when using `let`, the compiler assumes the variable may change and generalizes the type (e.g., `string`).

This behavior proves essential when working with discriminated unions or literal union types.
If you want to preserve a specific value as a type-level discriminant, always use `const` to prevent generalization.

## The `readonly` Modifier

`readonly` is a TypeScript-specific feature that prevents modification of object properties or array elements.
It works at the type level and provides compile-time protection:

```typescript
interface User {
  readonly id: number;
  name: string;
  readonly createdAt: Date;
}

const user: User = {
  id: 1,
  name: "Alice",
  createdAt: new Date()
};

user.name = "Bob"; // Allowed
// user.id = 2; // Error: Cannot assign to 'id' because it is a read-only property
// user.createdAt = new Date(); // Error: Cannot assign to 'createdAt' because it is a read-only property
```

You can also use `readonly` with arrays to prevent modification:

```typescript
function processNumbers(numbers: readonly number[]) {
  // numbers.push(4); // Error: Property 'push' does not exist on type 'readonly number[]'
  return numbers.map(n => n * 2); // Reading is allowed
}
```

## Key Differences

| Aspect         | `const`                                | `readonly`                            |
|----------------|----------------------------------------|---------------------------------------|
| **Scope**      | Variable binding                       | Object properties/array elements      |
| **Runtime**    | Enforced at runtime                    | TypeScript compile-time only          |
| **Mutability** | Prevents reassignment, allows mutation | Prevents property modification        |
| **Context**    | Variable declarations                  | Type definitions, function parameters |

## The `as const` Assertion

The `as const` assertion is a powerful TypeScript feature that creates the most specific possible type for a value, making it _deeply immutable_:

```typescript
// Without 'as const' - types are widened
const colors = ["red", "green", "blue"]; // Type: string[]
const point = { x: 10, y: 20 }; // Type: { x: number; y: number; }

// With 'as const' - types are narrowed and made readonly
const colorsConst = ["red", "green", "blue"] as const; 
// Type: readonly ["red", "green", "blue"]

const pointConst = { x: 10, y: 20 } as const;
// Type: { readonly x: 10; readonly y: 20; }
```

`const` is a JavaScript feature while `as const` is a TypeScript feature, which can be a little confusing.

### What `as const` Does

1. **Narrows literal types**: Instead of `string`, you get the specific literal type `"red"`
2. **Makes arrays readonly tuples**: `string[]` becomes `readonly ["red", "green", "blue"]`
3. **Makes object properties readonly**: Properties become `readonly` and their types become literal types
4. **Works recursively**: Nested objects and arrays are also made readonly

### Practical Examples

**Creating type-safe enums:**

```typescript
const STATUS = {
  PENDING: "pending",
  COMPLETED: "completed",
  FAILED: "failed"
} as const;

type Status = typeof STATUS[keyof typeof STATUS]; // "pending" | "completed" | "failed"

function updateStatus(status: Status) {
  // status must be one of the exact string literals
}
```

**Readonly configuration objects:**

```typescript
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3
} as const;

// config.apiUrl = "https://other.com"; // Error: Cannot assign to 'apiUrl' because it is a read-only property
```

In the above example, the object itself exists at runtime:

```javascript
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3
};
```

The `as const` assertion is purely a TypeScript compile-time feature which gets completely removed during compilation. 
It only affects the type system, not the runtime behavior.

So at runtime, you have a regular JavaScript object that you can:
- Read properties from: `config.apiUrl`
- Mutate: `config.timeout = 10000` (this will work at runtime)
- Pass to functions normally

If you try to mutate the `readonly` object in TypeScript code, you'll get a compile error, 
but if that code somehow made it to runtime (or if you're working directly with the compiled JavaScript), the mutation would succeed.

This is an important distinction - TypeScript's `readonly` and `as const` provide **compile-time safety**, not runtime immutability. 
If you need actual runtime immutability, you'd use something like `Object.freeze()`:

```typescript
const config = Object.freeze({
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3
} as const);
// Now it's both compile-time readonly AND runtime immutable
```

**Immutable arrays:**

```typescript
const directions = ["north", "south", "east", "west"] as const;
type Direction = typeof directions[number]; // "north" | "south" | "east" | "west"

// directions.push("up"); // Error: Property 'push' does not exist on type 'readonly ["north", "south", "east", "west"]'
```

## When to Use Each

- **Use `const`** for variable declarations when you don't want reassignment
- **Use `readonly`** in interfaces and type definitions to prevent property modification
- **Use `as const`** when you want the most specific, immutable type possible for literals and need compile-time guarantees about the exact values

Understanding these distinctions helps you write more robust TypeScript code with better type safety and clearer intentions about mutability.

## Type Inference

You often don't need to annotate types:

```ts
const itemCount = 5 // inferred as number
```

But understand how inference generalizes:

```ts
const currentMood = "happy"       // inferred as "happy"
let loadingStatus = "loading"     // inferred as string
```

This distinction arises because `const` implies immutability.
When you assign a literal to a `const`, TypeScript preserves the specific literal type (e.g., `"happy"`).
But when using `let`, the compiler assumes the variable may change and generalizes the type (e.g., `string`).

This behavior proves essential when working with discriminated unions or literal union types.
If you want to preserve a specific value as a type-level discriminant, always use `const` to prevent generalization.

## Template Literal Types

TypeScript lets you form new types from string literals using template syntax.
This proves particularly useful for describing patterned string values like tagged identifiers or URL patterns.

```ts
type UserID = `user-${number}`
```

This defines a type `UserID` that matches any string starting with `"user-"` followed by a number, such as `"user-1"` or `"user-42"`.
The compiler checks these types statically and enables powerful composition.

### Inference in Function Parameters

When you type a parameter using a template literal type,
TypeScript verifies that the passed string conforms exactly to the required pattern:

```ts
type ProductID = `product-${number}`

function fetchProduct(id: ProductID) {
  return `Fetching product with ID: ${id}`
}

console.log(fetchProduct("product-42"))  // OK
// fetchProduct("item-42") // Error: Argument of type '"item-42"' is not assignable to parameter of type 'ProductID'
```

In this example, TypeScript accepts `"product-42"` but rejects `"item-42"` because it doesn't start with `"product-"`.

### Interpolation with Union Types

You can combine template literal types with union types to describe broader sets of valid strings. This proves useful when modeling roles, statuses, or tagged names:

```ts
type SystemRole = "admin" | "editor"
type RoleBasedID = `${SystemRole}-${number}`

const editorIdentifier: RoleBasedID = "editor-7"  // OK
// const badIdentifier: RoleBasedID = "user-5"       // Error: "user" is not assignable to type 'SystemRole'
```

The `RoleBasedID` type describes any string composed of one of the allowed roles, followed by a hyphen and a number.
This gives you a strongly typed, pattern-matching string without requiring manual runtime validation.

You can combine template literal types with other type operations to create sophisticated string manipulation at the type level:

```ts
type ServicePrefix = "api" | "db"
type ResourceName = "user" | "product"
type ServiceEndpoint = `/${ServicePrefix}/${ResourceName}`

const userEndpoint: ServiceEndpoint = "/api/user"     // OK
const productEndpoint: ServiceEndpoint = "/db/product" // OK
// const invalidEndpoint: ServiceEndpoint = "/web/order"    // Error
```

This pattern proves particularly powerful for modeling APIs, configuration keys, CSS class names, or any domain where string patterns need validation at compile time.
