# Type Fundamentals

TypeScript builds a sophisticated type system on top of JavaScript's runtime behavior. This chapter covers the foundational concepts you need to understand how TypeScript works, clearly distinguishing between JavaScript features (available at runtime) and TypeScript features (compile-time only).

Understanding this distinction is crucial: JavaScript features exist when your code runs in the browser or Node.js, while TypeScript features help you catch errors and write better code during development but disappear after compilation.

## JavaScript's Runtime Types

TypeScript's type system mirrors JavaScript's runtime types. These are the actual data types that exist when your code executes, and you can inspect them using JavaScript's `typeof` operator.

### Primitive Types

JavaScript has seven primitive types that TypeScript directly supports:

```ts
let str: string = "hello"
console.log(typeof str) // "string"

let num: number = 42
console.log(typeof num) // "number"

let bool: boolean = true
console.log(typeof bool) // "boolean"

let big: bigint = 123n
console.log(typeof big) // "bigint"

let sym: symbol = Symbol("s")
console.log(typeof sym) // "symbol"

let undef: undefined = undefined
console.log(typeof undef) // "undefined"

let nul: null = null
console.log(typeof nul) // "object" (confusing!)
```

**JavaScript features here:**

- All the primitive values (`"hello"`, `42`, `true`, etc.)
- The `typeof` operator
- The confusing behavior where `typeof null` returns `"object"`

**TypeScript features here:**

- Type annotations (`: string`, `: number`, etc.)

#### Understanding Each Primitive

The `string` type represents textual data. JavaScript strings are immutable and can contain any Unicode characters.

The `number` type represents both integers and floating-point numbers. JavaScript uses IEEE 754 double-precision for all numbers, which has limitations for very large integers.

The `bigint` type represents arbitrarily large integers, beyond the safe integer limits of JavaScript's `number` type. You create them by appending `n` to integer literals, like `123n`. This solves the precision problems with very large numbers.

The `symbol` type represents unique, opaque values that serve as property keys or internal identifiers. Even two symbols with the same description are not equal:

```ts
const sym1 = Symbol("key")
const sym2 = Symbol("key")
console.log(sym1 === sym2) // false - they're unique!
```

The `undefined` type indicates the absence of a value or uninitialized state. It's the default value for uninitialized variables and missing function returns. JavaScript assigns `undefined` automatically in many situations.

The `null` type represents an intentional absence of any value. Unlike `undefined`, that often arises from language mechanics, developers assign `null` explicitly to indicate "no value here."

**Important:** The `typeof null === "object"` behavior is a famous JavaScript quirk that dates back to the language's early days. In TypeScript, you'll often need to handle this explicitly when checking for null values.

### Variable Declaration Keywords: `const` and `let`

Both `const` and `let` are JavaScript features introduced in ES2015 (ES6). They exist at runtime and control how variables are bound and scoped.

The `const` keyword creates an immutable binding to a value:

```typescript
const message = "Hello, world!";
// message = "Goodbye!"; // Error: Cannot assign to 'message' because it is a const

const numbers = [1, 2, 3];
// numbers = [4, 5, 6]; // Error: Cannot assign to 'numbers' because it is a const
```

**Important:** `const` only prevents reassignment of the variable itself, not mutation of the value it holds:

```typescript
const user = { name: "Alice", age: 30 };
user.age = 31; // This is allowed - we're mutating the object, not reassigning it

const items = [1, 2, 3];
items.push(4); // This is allowed - we're mutating the array, not reassigning it
```

The `let` keyword creates a mutable, block-scoped variable binding:

```typescript
let counter = 0
counter = 1  // Allowed - let permits reassignment

let message = "hello"
message = "goodbye"  // Also allowed
```

Both `const` and `let` are JavaScript features, but TypeScript adds type-related behavior on top of them.

## TypeScript's Type System

Now that we understand JavaScript's runtime types, let's explore how TypeScript adds compile-time type checking on top of them.

### Type Annotations and Inference

TypeScript can work in two ways: you can explicitly annotate types, or let TypeScript infer them for you.

**Explicit type annotations:**

```ts
let userName: string = "Alice"
let userAge: number = 30
let isActive: boolean = true
```

**Type inference (TypeScript figures it out):**

```ts
let userName = "Alice"     // inferred as string
let userAge = 30           // inferred as number
let isActive = true        // inferred as boolean
```

In most cases, TypeScript's inference is excellent, so you don't need to write type annotations everywhere. However, understanding when and why to use explicit annotations is important.

### How TypeScript Enhances `const` and `let`

While `const` and `let` are JavaScript features, TypeScript adds important type inference behavior:

```ts
const currentMood = "happy"       // TypeScript infers: "happy" (literal type)
let loadingStatus = "loading"     // TypeScript infers: string (general type)
```

**Why this difference?**

- With `const`, TypeScript knows the value can never change, so it preserves the exact literal type `"happy"`
- With `let`, TypeScript assumes you might reassign the variable, so it generalizes to `string` to allow any string value

This TypeScript-specific behavior becomes essential when working with discriminated unions and other advanced patterns:

```ts
const theme = "dark"  // Type: "dark" - can be used in literal unions
let mode = "dark"     // Type: string - too general for literal unions

type Theme = "light" | "dark"
let selectedTheme: Theme = theme  // OK - "dark" is assignable to Theme
// let selectedMode: Theme = mode    // Error - string is not assignable to Theme
```

**JavaScript at runtime:** Both variables just hold the string `"dark"`
**TypeScript at compile-time:** The `const` version has a more specific type that's useful for type checking

### Basic Array and Object Typing

**Arrays:**

```ts
let numbers: number[] = [1, 2, 3]        // Preferred modern syntax
let users: User[] = []
let matrix: number[][] = [[1, 2], [3, 4]]

// Alternative syntax you might see: Array<T>
let moreNumbers: Array<number> = [4, 5, 6]  // Less common

// Inferred array types
let fruits = ["apple", "banana"]  // inferred as string[]
```

The `number[]` syntax is preferred in modern TypeScript because it's more concise, reads naturally with array literals, and handles nested arrays more cleanly (`number[][]` vs `Array<Array<number>>`). You'll sometimes see
`Array<T>` in older codebases or when working with complex generic constraints.

**Object type literals:**

```ts
let user: { name: string; age: number } = {
  name: "Alice",
  age: 30
}

// Inferred object types
let product = {
  id: 1,
  name: "Widget"
}  // inferred as { id: number; name: string }
```

### Type Assertions

Sometimes you know more about a type than TypeScript can infer. Type assertions tell TypeScript "trust me, I know what this is":

```ts
let userInput: unknown = getUserInput()
let userName = userInput as string  // asserting it's a string

// Alternative syntax (avoid in JSX/TSX files)
let userAge = <number>userInput
```

**Note about JSX/TSX:** JSX (JavaScript XML) and TSX (TypeScript XML) are syntax extensions used in React that allow HTML-like code inside JavaScript/TypeScript. In `.jsx` and `.tsx` files, the `<type>` assertion syntax conflicts with JSX element syntax (`<div>`, `<button>`, etc.), so always use the
`as` syntax in React projects.

**Use with caution:** Type assertions don't perform runtime checks. If you're wrong, your code might break at runtime.

## Literal Types and Unions

TypeScript lets you create types that represent exact values, not just general categories.

### String, Number, and Boolean Literals

```ts
let direction: "left" | "right" | "center" = "left"
let statusCode: 200 | 404 | 500 = 200
let isComplete: true = true  // only accepts true, not false
```

These literal types are much more specific than their general counterparts (`string`, `number`, `boolean`). They create compile-time guarantees about exact values.

### Union Types

The `|` operator creates union types that hold values of multiple types:

```ts
let id: string | number = "user-123"
id = 456  // also valid

function displayResult(result: string | boolean) {
  if (typeof result === "string") {
    console.log(`Message: ${result}`)
  } else {
    console.log(`Success: ${result}`)
  }
}
```

**Why literal types matter:
** If you know enumerations (enums) from other languages, you can think of literal union types as a lightweight alternative. Both define a finite set of valid values, but enums introduce new named identifiers, while literal types work directly with the actual values. For many cases where the values themselves carry meaning (like
`"left"` or `"center"`), literal types prove more idiomatic in TypeScript.

### Discriminated Unions

Literal types form the foundation of discriminated unions, a powerful pattern for modeling variant data structures (data that takes different forms but represents the same concept):

```ts
type SuccessResult = { status: "ok"; data: string }
type FailureResult = { status: "error"; message: string }
type ApiResult = SuccessResult | FailureResult

function handleApiResult(result: ApiResult) {
  if (result.status === "ok") {
    console.log(result.data) // TypeScript knows this is SuccessResult
  } else {
    console.error(result.message) // TypeScript knows this is FailureResult
  }
}
```

The `status` field acts as a discriminant that helps TypeScript narrow the type within control flow. This pattern eliminates entire categories of runtime errors.

## Special TypeScript Types

TypeScript includes several special types that don't exist in JavaScript but solve common programming challenges.

### `any` - The Escape Hatch

The `any` type disables TypeScript's type checking entirely:

```ts
let data: any = 123
data.toUpperCase() // no error, even though numbers don't have toUpperCase()
data = "hello"
data = true
data = { anything: "goes" }
```

**When to use `any`:**

- Migrating JavaScript code to TypeScript gradually
- Working with dynamic content where types genuinely can't be known
- Interfacing with poorly-typed third-party libraries

**Why to avoid `any`:** It defeats the purpose of using TypeScript. Use it sparingly and deliberately, with a plan to replace it with proper types.

### `unknown` - The Safe Alternative

Like `any`, you assign anything to `unknown`, but you must narrow the type before using it:

```ts
function getRandomValue(): unknown {
  return Math.random() > 0.5 ? "hello" : 42
}

let userInput: unknown = getRandomValue()

// Must check the type before using
if (typeof userInput === "string") {
  console.log(userInput.toUpperCase()) // Safe!
}

// This would error:
// console.log(userInput.toUpperCase()) // Error: Object is of type 'unknown'
```

**When to use `unknown`:** When you genuinely don't know what type something will be, but want to handle it safely. It's much safer than `any` because it forces you to check types before using values.

### `void` - No Return Value

The `void` type indicates functions that don't return a meaningful value:

```ts
function displayMessage(message: string): void {
  console.log(message)
  // implicitly returns undefined
}

function logError(error: string): void {
  console.error(error)
  return // explicitly return nothing
}
```

Functions with `void` return type can return `undefined` explicitly, but callers should ignore the return value.

### `never` - Values That Never Occur

The `never` type represents values that should never exist:

```ts
function throwError(message: string): never {
  throw new Error(message)
  // This function never returns normally
}

function infiniteLoop(): never {
  while (true) {
    // This function never terminates
  }
}
```

**When you'll see `never`:** TypeScript uses `never` in exhaustive checks and to represent impossible states. It's more common in advanced type programming than everyday code.

## Immutability Patterns

TypeScript provides several ways to express immutability, each serving different purposes and operating at different levels.

### The `readonly` Modifier

`readonly` is a TypeScript-only feature that prevents modification at the type level. You can use it in several contexts:

**In interfaces and type definitions:**

```typescript
interface User {
  readonly id: number;
  name: string;
  readonly createdAt: Date;
}
```

**In object type literals:**

```typescript
let config: { readonly apiUrl: string; timeout: number } = {
  apiUrl: "https://api.example.com",  // No 'readonly' here - it's just the value
  timeout: 5000
}
// config.apiUrl = "https://other.com"; // Error: Cannot assign to readonly property
config.timeout = 10000; // Allowed - timeout is not readonly
```

**With arrays:**

```typescript
function processNumbers(numbers: readonly number[]) {
  // numbers.push(4); // Error: Property 'push' does not exist on type 'readonly number[]'
  return numbers.map(n => n * 2); // Reading is fine
}
```

The `n => n * 2` is an arrow function (ES6 JavaScript feature) - a concise way to write `function(n) { return n * 2; }`.

**With class properties:**

```typescript
class User {
  readonly id: number;
  name: string;
  
  constructor(id: number, name: string) {
    this.id = id; // Can set in constructor
    this.name = name;
  }
}
```

### The `as const` Assertion

The `as const` assertion is a powerful TypeScript feature that creates the most specific possible type for a value, making it deeply immutable:

```typescript
// Without 'as const' - types are widened
const colors = ["red", "green", "blue"]; // Type: string[]
const point = { x: 10, y: 20 }; // Type: { x: number; y: number; }

// With 'as const' - types are narrowed and made readonly
const colorsConst = ["red", "green", "blue"] as const; 
// Type: readonly ["red", "green", "blue"]

const pointConst = { x: 10, y: 20 } as const;
// Type: { readonly x: 10; readonly y: 20; }
```

**What `as const` does:**

1. Narrows literal types: Instead of `string`, you get `"red"`
2. Makes arrays readonly tuples: `string[]` becomes `readonly ["red", "green", "blue"]`
3. Makes object properties readonly and literal-typed
4. Works recursively on nested structures

**Practical example - type-safe constants:**

```typescript
const STATUS = {
  PENDING: "pending",
  COMPLETED: "completed",
  FAILED: "failed"
} as const;

type Status = typeof STATUS[keyof typeof STATUS]; // "pending" | "completed" | "failed"

function updateStatus(status: Status) {
  // status must be one of the exact string literals
}
```

This example uses two TypeScript features we haven't covered in detail yet:

- `typeof STATUS` gets the type of the STATUS object
- `keyof typeof STATUS` gets the union of all property names: `"PENDING" | "COMPLETED" | "FAILED"`
- `typeof STATUS[keyof typeof STATUS]` gets the union of all property values: `"pending" | "completed" | "failed"`

This pattern extracts the literal values from an object to create a union type, giving you type safety with your constants.

### Understanding the Differences

| Feature    | Scope                    | Runtime Effect         | Compile-time Effect                      |
|------------|--------------------------|------------------------|------------------------------------------|
| `const`    | Variable binding         | Prevents reassignment  | Preserves literal types                  |
| `readonly` | Object properties/arrays | None (TypeScript only) | Prevents modification                    |
| `as const` | Value literals           | None (TypeScript only) | Creates narrowest possible readonly type |

**Important:** TypeScript's immutability features provide compile-time safety, not runtime immutability. For actual runtime immutability, use `Object.freeze()`:

```typescript
const config = Object.freeze({
  apiUrl: "https://api.example.com",
  timeout: 5000
} as const);
// Now it's both compile-time readonly AND runtime immutable
```

## Advanced Type Patterns

### Template Literal Types

TypeScript creates new string types using template syntax, enabling powerful pattern matching at the type level:

```ts
type UserID = `user-${number}`
type ProductID = `product-${number}`

function fetchUser(id: UserID) {
  return `Fetching user with ID: ${id}`
}

fetchUser("user-42")  // OK
// fetchUser("product-42") // Error: wrong pattern
```

**Combining with unions:**

```ts
type SystemRole = "admin" | "editor" | "viewer"
type Permission = `${SystemRole}-access`

const editorPerm: Permission = "editor-access"  // OK
// const badPerm: Permission = "owner-access"     // Error: "owner" not in SystemRole
```

**API endpoint patterns:**

```ts
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE"
type ApiEndpoint = `/${string}`
type ApiCall = `${HttpMethod} ${ApiEndpoint}`

const userEndpoint: ApiCall = "GET /api/users"     // OK
const createUser: ApiCall = "POST /api/users"      // OK
// const invalidCall: ApiCall = "PATCH /api"        // Error: PATCH not allowed
```

This pattern proves particularly powerful for modeling APIs, configuration keys, CSS class names, or any domain where string patterns need compile-time validation.

### Function Type Basics

While we'll cover functions in detail later, understanding basic function typing helps complete the fundamentals:

```ts
// Function declaration with types
function greet(name: string): string {
  return `Hello, ${name}!`
}

// Function expression with types
const add = (a: number, b: number): number => {
  return a + b
}
// Arrow function syntax: (parameters): returnType => { body }

// Function type annotation
let calculator: (x: number, y: number) => number
calculator = add  // OK
calculator = greet  // Error: string parameters don't match number parameters
```

## Common Pitfalls and Best Practices

### Type Inference vs Explicit Annotations

**Good:** TypeScript infers when it's obvious

```ts
const userName = "Alice"  // clearly a string
const items = [1, 2, 3]   // clearly number[]
```

**Good:** Annotate when inference isn't clear or specific enough

```ts
let status: "loading" | "complete" | "error"  // could be just string without annotation
const config: { readonly apiUrl: string } = { apiUrl: "..." }  // want readonly
```

### The `null` and `undefined` Distinction

With `strictNullChecks` enabled (a TypeScript compiler option you set in `tsconfig.json`), TypeScript treats `null` and `undefined` as distinct types:

```ts
let name: string = "Alice"
// name = null      // Error with strictNullChecks
// name = undefined // Error with strictNullChecks

let optionalName: string | null = "Alice"
optionalName = null  // OK

let maybeName: string | undefined = "Alice"
maybeName = undefined  // OK
```

### When to Use Each Special Type

- **`any`**: Legacy code migration, truly dynamic content (use sparingly)
- **`unknown`**: Safe handling of dynamic content, API responses of unknown shape
- **`void`**: Functions that perform actions but don't return meaningful values
- **`never`**: Functions that never return, exhaustive type checking

## Summary

TypeScript's type system builds on JavaScript's runtime foundation while adding powerful compile-time guarantees. The key concepts from this chapter:

**JavaScript foundations:** Primitive types and `const` bindings provide the runtime behavior that TypeScript's types describe.

**TypeScript enhancements:** Type annotations, inference, and special types like `unknown` and `never` catch errors before runtime.

**Literal types and unions:** Enable precise modeling of allowed values and discriminated unions for variant data.

**Immutability tools:** `readonly`, `as const`, and proper use of `const` create safer, more predictable code.

**Template literal types:** Allow compile-time validation of string patterns, perfect for APIs and configuration.

Understanding these fundamentals prepares you for more advanced TypeScript features like interfaces, generics, and complex type manipulations. The type system becomes more powerful as you combine these basic building blocks in sophisticated ways.