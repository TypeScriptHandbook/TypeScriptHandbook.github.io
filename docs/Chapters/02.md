# Keywords and Operators

JavaScript provides the foundation for everything TypeScript does.
This chapter covers JavaScript's core language features: how variables work, how functions execute, how control flow operates, and how modern JavaScript features make code more expressive.
Every feature here exists at runtime and works identically whether you're writing JavaScript or TypeScript.

## The Evolution of Variable Declarations

JavaScript's approach to variable declarations reflects its evolution from a simple scripting language to a robust application platform.
This evolution created three distinct declaration keywords, each solving different problems.

### The Legacy of `var`

JavaScript originally provided only `var` for variable declarations:

```js
function demo() {
  console.log(x) // undefined (not an error!)
  var x = 5
  console.log(x) // 5
}
```

This behavior, called *hoisting*, moves variable declarations to the top of their function scope during compilation.
The declaration gets hoisted, but the assignment stays in place:

```js
// JavaScript internally rewrites the above as:
function demo() {
  var x // hoisted declaration
  console.log(x) // undefined
  x = 5 // assignment remains here
  console.log(x) // 5
}
```

Function-scoped variables created confusion in block-structured code:

```js
function processItems() {
  for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100) // Always prints 3!
  }
  console.log(i) // 3 (i leaked out of the loop)
}
```

### Modern Block Scoping

ES6 introduced `let` and `const` to provide block scoping and solve hoisting issues:

```js
function processItems() {
  for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100) // Prints 0, 1, 2
  }
  // console.log(i) // Error: i is not defined outside the loop
}
```

`let` and `const` are still hoisted, but they're placed in a "temporal dead zone" where they cannot be accessed before their declaration:

```js
function demonstrateDeadZone() {
  console.log(x) // ReferenceError: Cannot access 'x' before initialization
  // (not "undefined" like with var)
  
  let x = 5
  console.log(x) // 5
}

// Compare with var hoisting:
function demonstrateVar() {
  console.log(y) // undefined (hoisted but not initialized)
  var y = 10
  console.log(y) // 10
}
```

The temporal dead zone prevents the confusing behavior that `var` hoisting creates, making code more predictable.

`let` creates mutable block-scoped variables:

```js
let count = 1
count++ // OK
if (true) {
  let count = 10 // Different variable, shadows outer count
  console.log(count) // 10
}
console.log(count) // 2
```

`const` creates immutable bindings for primitive values:

```js
const name = "Alice"
// name = "Bob" // Error: Cannot assign to const variable
```

For objects, `const` prevents reassignment but allows mutation:

```js
const user = { name: "Alice", age: 30 }
user.age = 31 // OK: mutating the object
// user = { name: "Bob", age: 25 } // Error: cannot reassign
```

## JavaScript's Runtime Types

JavaScript has seven primitive types that represent the fundamental data that your programs work with:

```js
let str = "hello"
console.log(typeof str) // "string"

let num = 42
console.log(typeof num) // "number"

let bool = true
console.log(typeof bool) // "boolean"

let big = 123n
console.log(typeof big) // "bigint"

let sym = Symbol("s")
console.log(typeof sym) // "symbol"

let undef = undefined
console.log(typeof undef) // "undefined"

let nul = null
console.log(typeof nul) // "object" (confusing but historical!)
```

### Strings and Template Literals

`string`s represent textual data with Unicode support.
ES6 introduced template literals for string interpolation and multi-line strings:

```js
// Basic interpolation
const name = "Alice"
const greeting = `Hello, ${name}!` // "Hello, Alice!"

// Multi-line strings
const query = `
  SELECT id, name, email
  FROM users
  WHERE active = true
`

// Expression evaluation
const price = 19.99
const tax = 0.08
const total = `Total: $${(price * (1 + tax)).toFixed(2)}` // "Total: $21.59"
```

Template literals use backticks (`` ` ``) instead of quotes, and `${expression}` for interpolation. Any JavaScript expression can go inside `${}`:

```js
const items = ["apple", "banana", "cherry"]
const message = `You have ${items.length} items: ${items.join(", ")}`
// "You have 3 items: apple, banana, cherry"
```

### Numbers and Precision

`number`s represent both integers and floating-point numbers using IEEE 754 double-precision.
This has limitations for very large integers:

```js
console.log(Number.MAX_SAFE_INTEGER) // 9007199254740991
console.log(Number.MAX_SAFE_INTEGER + 1) // 9007199254740992
console.log(Number.MAX_SAFE_INTEGER + 2) // 9007199254740992 (lost precision!)
```

### BigInt for Large Integers

`bigint`s represent arbitrarily large integers beyond the safe integer limits of `number`.
You create them with the `n` suffix:

```js
const largeNumber = 9007199254740991n
const evenLarger = largeNumber + 1n // 9007199254740992n (precise!)

// Cannot mix bigint and number
// console.log(largeNumber + 1) // Error: Cannot mix BigInt and other types
console.log(largeNumber + BigInt(1)) // Must convert: 9007199254740992n
```

### Symbols for Unique Identifiers

`symbol`s represent unique, opaque values for property keys or internal identifiers.
Each symbol is unique, even with identical descriptions:

```js
const sym1 = Symbol("key")
const sym2 = Symbol("key")
console.log(sym1 === sym2) // false - each symbol is unique
```

### The null and undefined Distinction

`undefined` indicates absence of a value or uninitialized stateâ€”the default for uninitialized variables and missing function returns:

```js
let x
console.log(x) // undefined

function noReturn() {
  // implicit return undefined
}
console.log(noReturn()) // undefined
```

`null` represents intentional absence of any value. Unlike `undefined` which often arises from language mechanics, developers assign `null` explicitly:

```js
let data = null // explicitly "no data"
```

The `typeof null === "object"` behavior is a famous JavaScript quirk that dates back to the language's early days.

## Organizing Code with Functions and Classes

JavaScript supports multiple approaches to organizing reusable code, from simple functions to modern class syntax.

### Function Declarations and Hoisting

Functions serve as the primary unit of code organization:

```js
function calculateTotal(subtotal, taxRate) {
  return subtotal + calculateTax(subtotal, taxRate)
}

function calculateTax(amount, rate) {
  return amount * rate
}
```

Function declarations get hoisted, so you can call them before their definition:

```js
const total = calculateTotal(100, 0.08) // Works due to hoisting

function calculateTotal(subtotal, taxRate) {
  return subtotal + calculateTax(subtotal, taxRate)
}

function calculateTax(amount, rate) {
  return amount * rate
}
```

### Arrow Functions

ES6 introduced arrow functions for more concise function expressions:

```js
// Traditional function expression
const add = function(a, b) {
  return a + b
}

// Arrow function
const add = (a, b) => {
  return a + b
}

// Concise arrow function (implicit return)
const add = (a, b) => a + b

// Single parameter (parentheses optional)
const double = x => x * 2

// No parameters
const random = () => Math.random()
```

Arrow functions don't have their own `this` binding, making them useful for callbacks:

```js
class Timer {
  constructor() {
    this.seconds = 0
  }
  
  start() {
    // Arrow function preserves 'this' from the enclosing scope
    setInterval(() => {
      this.seconds++
      console.log(`${this.seconds} seconds`)
    }, 1000)
  }
}
```

### Modern Class Syntax

Classes provide a familiar structure for object-oriented programming:

```js
class BankAccount {
  constructor(initialBalance) {
    this.balance = initialBalance
  }
  
  deposit(amount) {
    this.balance += amount
  }
  
  getBalance() {
    return this.balance
  }
}

const account = new BankAccount(1000)
account.deposit(250)
console.log(account.getBalance()) // 1250
```

Classes support inheritance through `extends`:

```js
class SavingsAccount extends BankAccount {
  constructor(initialBalance, interestRate) {
    super(initialBalance) // Call parent constructor
    this.interestRate = interestRate
  }
  
  applyInterest() {
    const interest = this.getBalance() * this.interestRate
    this.deposit(interest)
  }
}
```

## Module System

JavaScript's module system organizes code across files using `import` and `export`:

```js
// user.js
export function createUser(name) {
  return { id: generateId(), name }
}

export function generateId() {
  return Math.floor(Math.random() * 10000)
}

// main.js
import { createUser } from "./user.js"

const newUser = createUser("Alice")
```

Default exports:

```js
// logger.js
export default class Logger {
  log(message) {
    console.log(`[${new Date().toISOString()}] ${message}`)
  }
}

// main.js
import Logger from "./logger.js"
const logger = new Logger()
```

## Control Flow and Logic

Control flow constructs determine how your program executes.

### Conditional Logic

Basic conditionals work with any expression that can be evaluated as truthy or falsy:

```js
function processOrder(order) {
  if (order.status === "pending") {
    console.log("Validating order...")
  } else if (order.status === "approved") {
    console.log("Fulfilling order...")
  } else {
    console.log(`Unknown status: ${order.status}`)
  }
}
```

JavaScript's truthy/falsy evaluation:

```js
// Falsy values: false, 0, -0, 0n, "", null, undefined, NaN
// Everything else is truthy

if (user.name) {
  console.log(`Hello, ${user.name}`)
} else {
  console.log("Hello, anonymous user")
}
```

`switch` statements enable pattern matching on discrete values:

```js
function handleUserAction(action) {
  switch (action.type) {
    case "login":
      console.log(`Authenticating with ${action.credentials}`)
      break
    case "logout":
      console.log(`Clearing session for user ${action.userId}`)
      break
    case "updateProfile":
      console.log(`Updating profile for user ${action.userId}`)
      break
    default:
      throw new Error(`Unhandled action: ${action.type}`)
  }
}
```

### Iteration

JavaScript supports multiple iteration patterns:

```js
const numbers = [1, 2, 3, 4, 5]

// Traditional for loop
for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i])
}

// for...of iterates over values
for (const number of numbers) {
  console.log(number)
}

// for...in iterates over keys (avoid with arrays)
const user = { name: "Alice", age: 30 }
for (const key in user) {
  console.log(`${key}: ${user[key]}`)
}

// while and do-while loops
let count = 0
while (count < 5) {
  console.log(count)
  count++
}

do {
  console.log("This runs at least once")
} while (false)
```

## Operators and Expressions

JavaScript's operators handle both traditional computations and modern patterns like optional access and nullish coalescing.

### Arithmetic and Assignment

Standard mathematical operations:

```js
const subtotal = 100
const taxRate = 0.08
const tax = subtotal * taxRate
const total = subtotal + tax

let balance = 1000
balance += 250  // balance = balance + 250
balance *= 1.02 // apply 2% interest
```

### Comparison and Equality

JavaScript provides both loose and strict equality:

```js
console.log(5 == "5")  // true (type coercion)
console.log(5 === "5") // false (strict equality)

// Type coercion examples
console.log(0 == false)      // true
console.log("" == false)     // true
console.log(null == undefined) // true

// Always prefer strict equality
console.log(0 === false)     // false
console.log("" === false)    // false
console.log(null === undefined) // false
```

Always use strict equality (`===` and `!==`) unless you specifically need type coercion.

### Logical Operations

Logical operators support both boolean logic and value selection:

```js
// Boolean logic
const isAuthenticated = true
const hasPermission = checkUserPermission()
const canAccess = isAuthenticated && hasPermission

// Short-circuit evaluation for default values
const user = { name: "" }
const username = user.name || "Anonymous"  // "Anonymous" because "" is falsy

// Nullish coalescing for more precise defaults (ES2020)
const config = { timeout: 0 }
const timeout = config.timeout ?? 5000  // 0 (only replaces null/undefined)
const port = config.port ?? 3000         // 3000 (port is undefined)
```

The difference between `||` and `??`:
- `||` replaces any falsy value (`false`, `0`, `""`, `null`, `undefined`)
- `??` only replaces `null` and `undefined`

### Modern Property Access

Optional chaining (`?.`) safely accesses nested properties:

```js
const user = {
  profile: {
    address: {
      street: "123 Main St",
      city: "Boston"
    }
  }
}

// Traditional defensive checking
const city = user && user.profile && user.profile.address && user.profile.address.city

// Optional chaining (ES2020)
const city = user?.profile?.address?.city  // "Boston"

// Works with arrays and method calls
const firstItem = user?.items?.[0]
user?.processPayment?.()
```

If any part of the chain is `null` or `undefined`, the entire expression returns `undefined`.

### Destructuring and Spread

Destructuring extracts values from objects and arrays:

```js
// Object destructuring
const user = { name: "Alice", age: 30, email: "alice@example.com" }
const { name, age } = user
const { name: userName, ...otherProps } = user  // Rename and collect rest

// Array destructuring
const numbers = [1, 2, 3, 4, 5]
const [first, second, ...rest] = numbers
const [, , third] = numbers  // Skip elements

// Function parameter destructuring
function greetUser({ name, age }) {
  console.log(`Hello ${name}, you are ${age} years old`)
}
```

Spread syntax expands collections:

```js
// Object spread
const originalUser = { name: "Alice", age: 30 }
const updatedUser = { ...originalUser, age: 31 }

// Array spread
const moreNumbers = [...numbers, 6, 7, 8]
const combined = [...numbers, ...moreNumbers]

// Function call spread
function sum(a, b, c) {
  return a + b + c
}
const args = [1, 2, 3]
console.log(sum(...args))  // Same as sum(1, 2, 3)
```

## The Versatile Square Bracket

Square brackets serve multiple purposes in JavaScript, making them one of the most context-dependent syntactic elements.

### Runtime Uses

Array literals and indexing:

```js
const fruits = ["apple", "banana", "cherry"]
const first = fruits[0]              // "apple"
const last = fruits[fruits.length - 1] // "cherry"
```

Dynamic property access:

```js
const propertyName = "score"
const user = { name: "Alice", score: 95 }
const value = user[propertyName]     // 95
const staticValue = user.score       // Same as above, but static

// Useful for computed property names
const key = "user_" + userId
const data = cache[key]

// Setting dynamic properties
const settings = {}
settings[`theme_${mode}`] = "dark"
```

Computed property names in object literals:

```js
const prefix = "api"
const config = {
  [`${prefix}_url`]: "https://api.example.com",
  [`${prefix}_timeout`]: 5000
}
// Creates: { api_url: "https://api.example.com", api_timeout: 5000 }
```

## Error Handling and Control Transfer

JavaScript provides structured error handling and early exit mechanisms.

### Exception Handling

The `try-catch-finally` construct handles errors gracefully:

```js
function parseUserData(jsonString) {
  try {
    const userData = JSON.parse(jsonString)
    
    if (!userData.name) {
      throw new Error("User data missing required 'name' field")
    }
    
    return userData
  } catch (error) {
    console.error("Failed to parse user data:", error.message)
    return null  // Provide fallback
  } finally {
    console.log("Parse attempt completed")  // Always runs
  }
}
```

Async error handling:

```js
async function fetchUserData(id) {
  try {
    const response = await fetch(`/api/users/${id}`)
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }
    
    return await response.json()
  } catch (error) {
    console.error("Failed to fetch user:", error)
    throw error  // Re-throw for caller to handle
  } finally {
    console.log("Fetch attempt completed")
  }
}
```

### Custom Error Types

You can create custom error classes for better error handling:

```js
class ValidationError extends Error {
  constructor(field, value) {
    super(`Invalid ${field}: ${value}`)
    this.name = "ValidationError"
    this.field = field
    this.value = value
  }
}

function validateAge(age) {
  if (age < 0 || age > 150) {
    throw new ValidationError("age", age)
  }
}

try {
  validateAge(-5)
} catch (error) {
  if (error instanceof ValidationError) {
    console.log(`Validation failed for ${error.field}`)
  } else {
    console.log("Unexpected error:", error)
  }
}
```

### Early Exit

`return` exits functions early:

```js
function processUser(user) {
  if (!user.isActive) {
    return // Early exit for inactive users
  }
  
  if (!user.hasPermission) {
    console.log("User lacks permission")
    return
  }
  
  // Continue processing active user with permission
  console.log("Updating last seen...")
  console.log("Sending welcome email...")
}
```

`break` and `continue` control loop execution:

```js
function findFirstEven(numbers) {
  for (const num of numbers) {
    if (num % 2 !== 0) {
      continue // Skip odd numbers
    }
    
    if (num > 100) {
      break // Stop if we find a large even number
    }
    
    return num // Return first small even number
  }
  
  return undefined // No suitable number found
}
```

Labeled statements for complex control flow:

```js
outer: for (let i = 0; i < 3; i++) {
  inner: for (let j = 0; j < 3; j++) {
    if (i === 1 && j === 1) {
      break outer // Break out of both loops
    }
    console.log(`${i}, ${j}`)
  }
}
```

## Advanced JavaScript Features

### Promises and Async/Await

Modern JavaScript handles asynchronous operations with Promises:

```js
// Promise-based approach
function fetchData() {
  return fetch('/api/data')
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok')
      }
      return response.json()
    })
    .then(data => {
      console.log('Data received:', data)
      return data
    })
    .catch(error => {
      console.error('Fetch error:', error)
      throw error
    })
}
```

Async/await syntax (ES2017):

```js
async function fetchData() {
  try {
    const response = await fetch('/api/data')
    
    if (!response.ok) {
      throw new Error('Network response was not ok')
    }
    
    const data = await response.json()
    console.log('Data received:', data)
    return data
  } catch (error) {
    console.error('Fetch error:', error)
    throw error
  }
}
```

Parallel execution:

```js
async function fetchMultipleResources() {
  try {
    // Sequential (slower)
    const user = await fetchUser(userId)
    const posts = await fetchPosts(userId)
    
    // Parallel (faster)
    const [user, posts] = await Promise.all([
      fetchUser(userId),
      fetchPosts(userId)
    ])
    
    return { user, posts }
  } catch (error) {
    console.error('Failed to fetch resources:', error)
  }
}
```

### Generators and Iterators

Generators create custom iterables:

```js
function* numberGenerator() {
  let num = 1
  while (true) {
    yield num++
  }
}

const gen = numberGenerator()
console.log(gen.next().value) // 1
console.log(gen.next().value) // 2

// Finite generator
function* fibonacci(max) {
  let a = 0, b = 1
  while (a <= max) {
    yield a
    ;[a, b] = [b, a + b]
  }
}

for (const num of fibonacci(100)) {
  console.log(num) // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89
}
```

### Symbols and Well-Known Symbols

Symbols create unique property keys:

```js
const SECRET_KEY = Symbol('secret')
const user = {
  name: "Alice",
  [SECRET_KEY]: "confidential data"
}

console.log(user.name)        // "Alice"
console.log(user[SECRET_KEY]) // "confidential data"

// Symbols don't appear in normal enumeration
Object.keys(user)           // ["name"]
Object.getOwnPropertyNames(user) // ["name"]
Object.getOwnPropertySymbols(user) // [Symbol(secret)]
```

Well-known symbols customize object behavior:

```js
class NumberRange {
  constructor(start, end) {
    this.start = start
    this.end = end
  }
  
  // Make the object iterable
  *[Symbol.iterator]() {
    for (let i = this.start; i <= this.end; i++) {
      yield i
    }
  }
  
  // Custom string representation
  [Symbol.toStringTag] = 'NumberRange'
}

const range = new NumberRange(1, 5)
for (const num of range) {
  console.log(num) // 1, 2, 3, 4, 5
}

console.log(range.toString()) // "[object NumberRange]"
```

## Runtime Immutability

JavaScript provides several ways to create immutable data structures at runtime.

### Object.freeze()

```js
const config = Object.freeze({
  apiUrl: "https://api.example.com",
  timeout: 5000
})

// config.timeout = 10000 // Error in strict mode, silently fails otherwise
console.log(config.timeout) // Still 5000
```

Shallow vs deep freezing:

```js
const shallowFrozen = Object.freeze({
  name: "Alice",
  settings: { theme: "dark" }
})

// shallowFrozen.name = "Bob"           // Error: can't modify frozen object
shallowFrozen.settings.theme = "light" // OK: nested objects aren't frozen

// Deep freeze utility
function deepFreeze(obj) {
  Object.getOwnPropertyNames(obj).forEach(prop => {
    if (obj[prop] !== null && typeof obj[prop] === "object") {
      deepFreeze(obj[prop])
    }
  })
  return Object.freeze(obj)
}
```

### Object.seal() and Object.preventExtensions()

```js
const sealed = Object.seal({ name: "Alice", age: 30 })
sealed.age = 31        // OK: can modify existing properties
// sealed.email = "..."   // Error: can't add new properties

const nonExtensible = Object.preventExtensions({ name: "Alice" })
nonExtensible.name = "Bob" // OK: can modify existing properties
// nonExtensible.age = 30    // Error: can't add new properties
```

## Putting It All Together

Here's an example that combines many JavaScript features to create a flexible, maintainable system:

```js
// Custom error for domain-specific problems
class ValidationError extends Error {
  constructor(field, value) {
    super(`Invalid ${field}: ${value}`)
    this.name = "ValidationError"
    this.field = field
    this.value = value
  }
}

// Class with modern JavaScript features
class DatabaseConnection {
  constructor(config) {
    this.config = { ...config } // Spread for shallow copy
    this.isConnected = false
  }
  
  async connect() {
    try {
      const { host, port, credentials } = this.config // Destructuring
      
      if (!host || !port) {
        throw new ValidationError("connection", "Missing host or port")
      }
      
      // Optional chaining for credentials
      const auth = credentials?.username && credentials?.password
        ? { user: credentials.username, pass: credentials.password }
        : null
      
      // Template literal for connection string
      const connectionString = `${host}:${port}`
      
      // Simulate async connection
      await new Promise(resolve => setTimeout(resolve, 100))
      
      this.isConnected = true
      console.log(`Connected to ${connectionString}`)
      
      return this
    } catch (error) {
      console.error("Connection failed:", error.message)
      throw error
    } finally {
      console.log("Connection attempt completed")
    }
  }
  
  // Generator for query results
  async *query(sql) {
    if (!this.isConnected) {
      throw new Error("Not connected to database")
    }
    
    // Simulate streaming results
    const results = await this.executeQuery(sql)
    
    for (const row of results) {
      yield row
    }
  }
  
  async executeQuery(sql) {
    // Simulate database query
    return [
      { id: 1, name: "Alice" },
      { id: 2, name: "Bob" }
    ]
  }
}

// Usage combining multiple JavaScript features
async function demonstrateUsage() {
  const config = {
    host: "localhost",
    port: 5432,
    credentials: {
      username: "admin",
      password: "secret"
    }
  }
  
  try {
    const db = new DatabaseConnection(config)
    await db.connect()
    
    // Use generator for memory-efficient iteration
    for await (const row of db.query("SELECT * FROM users")) {
      console.log(`User: ${row.name}`)
    }
  } catch (error) {
    if (error instanceof ValidationError) {
      console.error(`Validation error in ${error.field}:`, error.message)
    } else {
      console.error("Database operation failed:", error)
    }
  }
}
```

## Takeaways

1. _JavaScript provides the runtime foundation:_ Every feature in this chapter exists when your code executes, forming the basis for everything TypeScript adds.

2. _Modern JavaScript is expressive:_ ES6+ features like arrow functions, destructuring, template literals, and async/await make code more readable and maintainable.

3. _Block scoping improves predictability:_ Prefer `let` and `const` over `var` for clearer scoping and the temporal dead zone's error prevention.

4. _Error handling is crucial:_ Use try-catch for synchronous code and proper async error handling for asynchronous operations.

5. _Multiple programming paradigms:_ JavaScript supports functional programming (higher-order functions, immutability), object-oriented programming (classes, inheritance), and procedural programming.

6. _Operators enable safe access:_ Modern operators like optional chaining (`?.`), nullish coalescing (`??`), and spread syntax (`...`) make code more resilient.

7. _Runtime immutability complements development safety:_ `Object.freeze()` and related methods provide runtime protection beyond development-time checks.

TypeScript builds its type system on top of these JavaScript fundamentals.
In the next chapter you'll see how TypeScript adds compile-time safety and enhanced developer experience to these runtime behaviors.