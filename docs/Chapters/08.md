# Enums and Const Assertions

Use enums to define a fixed set of named constants, either numeric or string-based.
TypeScript supports enumerated types using the `enum` keyword.
An `enum` defines a fixed set of named constants.
Numbers and strings are the only two value types allowed; TypeScript enums cannot contain booleans, objects, or other complex types.
Additionally, `as const` assertions allow precise inference of literal types.

## Numeric Enums

By default, enums are numeric, starting from 0:

```ts
enum Direction {
  Up,
  Down,
  Left,
  Right
}

const move = Direction.Left
console.log(move) // 2
```

You can override the starting value or assign specific numbers:

```ts
enum Status {
  Ready = 1,
  Waiting = 3,
  Finished = 5
}
```

## String Enums

String enums require an explicit initializer:

```ts
enum Response {
  Yes = "YES",
  No = "NO"
}

const reply = Response.Yes
console.log(reply) // "YES"
```

## Const Enums

Use `const enum` for performance.
Values are inlined and there's no emitted object:

```ts
const enum Color {
  Red,
  Green,
  Blue
}

const c = Color.Green // Inlined as `1`
```

Const enums are erased at runtime, which improves efficiency but removes runtime access to enum metadata.

## Literal Inference with `as const`

You first saw `as const` used to preserve array and tuple types in Chapter 7.
Here, we extend that idea to enable union type inference.

Use `as const` to preserve exact literal values:

```ts
const ROLES = ["admin", "user", "guest"] as const
```

Without `as const`, the array is inferred as `string[]`.
With it, TypeScript infers the type as `readonly ["admin", "user", "guest"]`.

You can use it to create a union type:

```ts
type Role = typeof ROLES[number]
```

This is equivalent to:

```ts
type Role = "admin" | "user" | "guest"
```

This pattern is preferred over enums when you want exhaustive string-based typing without the enum overhead.
Use `as const` and `typeof` for lightweight, literal unions—especially in modern codebases that avoid traditional enums.

## Enum-Like Alternatives Using Mapped Types

In TypeScript, you cannot directly generate enums using mapped types, because enum is a distinct TypeScript syntax construct.
It’s not based on the type system in a way that would allow mapping or transformation:

```ts
// Not valid; doesn't create a runtime enum
type MyEnum = {
    [K in 'A' | 'B' | 'C']: K 
}
```

Mapped types operate at the type level only and do not emit runtime values, which are required for an `enum`.
However, you can simulate `enum`-like behavior using union types, const objects, and mapped types.
Here's how, along with their tradeoffs:

### 1. Union of String Literals + Object Mapping

```ts
const keys = ['A', 'B', 'C'] as const
type MyEnum = (typeof keys)[number] // "A" | "B" | "C"

const MyEnumValues: { [K in MyEnum]: K } = Object.fromEntries(
  keys.map(k => [k, k])
) as { [K in MyEnum]: K }
```

This gives you:

* A type: `"A" | "B" | "C"`
* A runtime object: `{ A: "A", B: "B", C: "C" }`

This behaves similarly to `enum`, without the weird TypeScript `enum` quirks (e.g. bidirectional maps, runtime presence, etc.).

### 2. Const Object with `as const`

```ts
export const MyEnum = {
  A: 'A',
  B: 'B',
  C: 'C'
} as const

export type MyEnum = keyof typeof MyEnum // "A" | "B" | "C"
export type MyEnumValue = typeof MyEnum[MyEnum] // "A" | "B" | "C"
```

This is often better than `enum` because:

* It is fully typed
* It has runtime presence
* It avoids `enum` issues in JavaScript interop
* You can map over it

### 3. Mapped Type-Based Enum Simulation

You can generate the runtime object via a mapped type over a string union:

```ts
type Keys = 'Red' | 'Green' | 'Blue'

const ColorEnum: { [K in Keys]: K } = {
  Red: 'Red',
  Green: 'Green',
  Blue: 'Blue'
}
```

If you want numeric values:

```ts
const ColorEnum: { [K in Keys]: number } = {
  Red: 0,
  Green: 1,
  Blue: 2
}
```

Again, you must emit a runtime object manually.
TypeScript types alone won’t emit values.

### Generic Enum Builder

You can define a generic utility function that takes a `readonly` tuple of strings (`as const` array), 
and returns an object mapping each key to itself, with full type safety and inference:

```ts
function createEnumFromKeys<const T extends readonly string[]>(
  keys: T
): { [K in T[number]]: K } {
  return Object.fromEntries(keys.map(k => [k, k])) as { [K in T[number]]: K }
}
```

* `T extends readonly string[]` ensures that `keys` is a literal tuple, not just `string[]`.
* `T[number]` gives you the union of values in the tuple.
* The result type maps each key `"K"` to its corresponding string literal `"K"`.

Here's a usage example:

```ts
const keys = ['A', 'B', 'C'] as const

const MyEnumValues = createEnumFromKeys(keys)
// const MyEnumValues: { A: "A"; B: "B"; C: "C" }

type MyEnum = keyof typeof MyEnumValues
// type MyEnum = "A" | "B" | "C"
```

If you want the result to be deeply immutable, assert it `as const` when returning:

```ts
function createEnumFromKeys<const T extends readonly string[]>(
  keys: T
): { readonly [K in T[number]]: K } {
  const result = Object.fromEntries(keys.map(k => [k, k])) as {
    [K in T[number]]: K
  }
  return result as const
}
```
