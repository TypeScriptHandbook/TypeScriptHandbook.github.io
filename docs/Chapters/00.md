# Preface

This book is for developers who have a firm grasp of two or more programming languages, but not JavaScript or TypeScript.
The goal is to quickly give the experienced programmer a tour of the language,
including all the odd and obscure bits so you aren't flummoxed when you see them in practice.
Because you know two or more languages, you've seen similarities and differences between languages.
From experience, you know the concepts and what to expect from a language, you just don't know the details of how TypeScript does it.

## Writing Tools

I began writing by hand. Eventually I got my father's old manual typewriter.
When I went to college I got a "portable" (luggable) electric typewriter, for my first year as a journalism major, before changing to Physics.
After grad school I was able to buy one of the early personal computers, a Kaypro (also luggable).
Eventually we got spell checking, and then word processors, which have continued to improve over the decades.
The Internet removed the need to hunt through books, and to wait for books that caught up with language changes 
(I've gotten rid of all my programming books except those written by friends).
Now we have LLM's: yet another tool in the progress of automation.
I am in the process of learning to use this new tool to create books.
Like the Internet, LLM's may end up replacing many kinds of books, and programming books will probably go first.
ChatGPT and Claude have been extremely helpful in doing research and creating and revising drafts (as well as creating tooling for book development and testing).
They've sped things up dramatically and made it worth trying this book as an experiment.
Ultimately, however, I still need to discover missed topics, carefully edit, rewrite and craft the book.
Yes, it's a lot faster and removes a lot of tedious work, but it's still writing -- just with a much better tool than we've had in the past.

## Inception

Bill Frasure, James Ward and I worked for four years on [Effect Oriented Programming](https://effectorientedprogramming.com).
We're still trying to figure out how to explain those concepts clearly.
When the team working on the TypeScript Effect library reached out and asked that we translate the book to this new language and library, we hesitated.
None of us knew TypeScript (TS), and although the Effect library is based on ZEO (which we used in the book), 
there were a lot of foreign ideas in the language and library.
JavaScript (JS) has a ... checkered past, and TypeScript is a compromise language to make transition easier for JavaScript programmers.
Because of this, we acknowledged (at least I think we did) that the learning curve would be bigger than we might expect.

JS/TS has a syntax that, upon first glance, looks familiar enough that we thought we could cargo-cult our way through.
But as I started working into the Effect docs, I found them casually using features that were really quite puzzling.
After delving into a few of these, I had a _we're-not-in-Kansas-anymore_ moment (see _The Wizard of Oz_).
We needed to actually learn this language in depth.

I wondered if I could coach LLMs into creating the book that the three of us needed.
After I started, I remembered that writing a book is a very effective way for me to learn a language.

## Outline

### Chapter 1: Context and Philosophy

- JavaScript: The TypeScript Substrate
- Why TypeScript?
  - The Rise of TypeScript
  - Early Design Goals
  - Influences and Inspirations
  - Widespread Adoption
- Structural Typing vs. Nominal Typing
  - The Benefits of Structural Typing
  - The Pitfalls of Structural Typing
  - Mental Models for Navigating TypeScript's System

### Chapter 2: Keywords and Operators

- The Evolution of Variable Declarations
  - The Legacy of `var`
  - Modern Block Scoping
- JavaScript's Runtime Types
  - Strings and Template Literals
  - Numbers and Precision
  - BigInt for Large Integers
  - Symbols for Unique Identifiers
  - The null and undefined Distinction
- Organizing Code with Functions and Classes
  - Function Declarations and Hoisting
  - Arrow Functions
  - Modern Class Syntax
- Module System
- Control Flow and Logic
  - Conditional Logic
  - Iteration
- Operators and Expressions
  - Arithmetic and Assignment
  - Comparison and Equality
  - Logical Operations
  - Modern Property Access
  - Destructuring and Spread
- The Versatile Square Bracket
  - Runtime Uses
- Error Handling and Control Transfer
  - Exception Handling
  - Custom Error Types
  - Early Exit
- Advanced JavaScript Features
  - Promises and Async/Await
  - Generators and Iterators
  - Symbols and Well-Known Symbols
- Runtime Immutability
  - Object.freeze()
  - Object.seal() and Object.preventExtensions()
- Putting It All Together
- Takeaways

### Chapter 3: Type Fundamentals

- TypeScript's Role: Describing JavaScript
  - Type Annotations and Inference
  - How TypeScript Enhances Variable Declarations
  - Arrays and Objects with Types
  - Type Assertions: When You Know More
- Literal Types and Unions
  - String, Number, and Boolean Literals
  - Union Types with `|`
  - Discriminated Unions: Modeling Complex Data
- Special TypeScript Types
  - `any` - The Escape Hatch
  - `unknown` - The Safe Alternative
  - `void` - No Return Value
  - `never` - Values That Never Occur
- Immutability in TypeScript's Type System
  - The `readonly` Modifier
  - The `as const` Assertion
  - Combining Compile-time and Runtime Immutability
  - Immutability Feature Comparison
- Advanced Type Patterns
  - Template Literal Types
  - Function Types
  - Index Signatures and Mapped Types
- Strict Null Checking
  - Type Guards and Narrowing
- Bringing TypeScript and JavaScript Together
- Key Takeaways

### Chapter 4: The JavaScript Object Model

- Object Fundamentals
  - Objects Are Key-Value Maps
  - Dynamic Modification
  - Object Utility Functions
  - `this` and Method Binding
- The Prototype System
  - Constructor Functions
    - What `new` Does
    - Any Function Can Be a Constructor
    - Return Values in Constructors
  - The Prototype Property
    - When Does a Function Get a Prototype?
    - The Constructor Property
    - Adding Methods to the Prototype
    - Prototype Properties Are Live
    - Common Mistake: Adding to Instance Instead of Prototype
    - Replacing the Entire Prototype
  - Prototype Chain and Inheritance
    - Basic Inheritance Example
    - Understanding the Prototype Chain
    - Method Resolution and Overriding
    - Accessing Parent Methods
    - The Internal `[[Prototype]]` Link
    - Creating Objects with Specific Prototypes
    - Prototype Chain Termination
- Modern JavaScript Classes
  - Basic Class Declaration
  - Class vs Constructor Function Equivalence
  - Class Fields
  - Class Inheritance with `extends`
  - Using `super` to Access Parent Methods
  - Classes Enforce Constructor Usage
  - Static Methods
  - Benefits of Class Syntax
  - TypeScript Class Enhancements
- Advanced Techniques
  - Static Factory Methods
  - `Object.defineProperty` for Fine-Grained Control
  - Proxy-Based Objects
  - Singleton Pattern with Module Closure
  - Symbol-Based Private Methods
  - Object Reconstruction from JSON
  - Mixin Pattern
  - When to Use These Patterns
- Key Concepts

### Chapter 5: Functions and Signatures

- Function Declarations vs Expressions
  - Function Declarations
  - Function Expressions
  - Arrow Functions
  - When to Use Each Style
- Parameters
  - Required Parameters
  - Optional Parameters
  - Default Parameters
  - Rest Parameters
- Function Types
  - Basic Function Types
  - Function Types with Optional Parameters
  - Function Types with Rest Parameters
  - Higher-Order Function Types
- Overloads
  - Basic Overloads
  - Overloads with Different Return Types
  - Overloads vs. Union Types
  - Practical Overload Example
- `this` in Functions
  - `this` in Regular Functions
  - `this` in Arrow Functions
  - Typing `this` Parameters
  - `this` in Class Methods
  - Binding Methods
- `void` vs `undefined`
  - When to Use `void`
  - When to Use `undefined`
  - The Practical Difference
  - `void` in Function Types
- Function Signature Best Practices
  - Prefer Specific Types Over Generic Ones
  - Use Overloads for Complex APIs
  - Design for Immutability
  - Use Descriptive Parameter Names

### Chapter 6: Objects, Interfaces, and Type Aliases

- Describing Object Shapes
- Initializing Class Instances
  - Using Static Factory Methods
  - Dependency Injection
- Access Modifiers
- Inheritance
- Abstract Classes
- Types vs Interfaces
- Extending Types
- Optional and Readonly Properties
- Index Signatures
- Excess Property Checks

### Chapter 7: Arrays, Tuples, and Readonly Types

- Arrays
- Tuples
- Readonly Arrays and Tuples

### Chapter 8: Enums and Const Assertions

- Numeric Enums
- String Enums
- Const Enums
- Literal Inference with `as const`
- Enum-Like Alternatives Using Mapped Types
  - 1. Union of String Literals + Object Mapping
  - 2. Const Object with `as const`
  - 3. Mapped Type-Based Enum Simulation
  - Generic Enum Builder

### Chapter 9: Type Inference and Control

- Basic Inference
- Type Narrowing
- Contextual Typing

### Chapter 10: Union and Intersection Types

- Basics
- Discriminated Unions
- Exhaustiveness Checks
- Intersection Types
- Common Mistakes and Clarity Techniques

### Chapter 11: Generics

- Generic Functions and Types
- Constraint-Based Design
- Type Defaults and Inference Quirks
- Variance
  - Covariance
  - Contravariance
  - Bivariance and Invariance
  - Variance Annotations

### Chapter 12: Type Transformations

- Conditional Types
  - Using `infer` to Extract Types
  - Recursive Conditional Types
- Template Literal Types
- `keyof` and Indexed Access Types
- `typeof` and `as const`
- Mapped Types
  - Predefined Mapped Types
- Key Remapping and Filtering
- Template Literal Types with Mapped Types
- Conditional Logic in Mapped Types

### Chapter 13: Artificial Nominal Typing

- TypeScript Improvements and Limitations
- The Global Symbol Registry and Branding
  - What is a Symbol?
  - The Global Symbol Registry
  - Computed Property Keys
  - `unique symbol`
  - Using Branding to Produce Nominal Typing
- Using Branding to Solve the Robot/Human Problem
  - Are Type Tags Redundant with Branding?
