# Type Transformations

Conditional and mapped types provide powerful tools for transforming types.
They encode logic into the type system itself, enabling flexible, reusable, and expressive type definitions.
They let you:

* Perform conditional branching (`extends ? :`)
* Extract types (`infer`)
* Define recursive patterns
* Transform, filter, and remap keys
* Combine transformations for high-level type logic

Together, they provide the foundation for most advanced type-level programming in TypeScript.

## Conditional Types

A conditional type selects one of two possible types depending on a condition.
They follow this form:

```ts
// Basic conditional type syntax
type ConditionalExample<T> = T extends string ? "is string" : "not string"

// Test the conditional type
type Test1 = ConditionalExample<string>  // "is string"
type Test2 = ConditionalExample<number>  // "not string"
```

Read: "If `T` is assignable to `string`, then the type is `"is string"`, otherwise it's `"not string"`."

We typically use conditional types with generics:

```ts
type IsString<T> = T extends string ? true : false
type A = IsString<string>  // true
type B = IsString<number>  // false
```

Conditional types are evaluated entirely at compile time. 
In the above example, `IsString<string>` resolves to `true` because `string` extends `string` is `true`. 
Likewise, `IsString<number>` resolves to `false`.

We assign the result of a conditional type to a type alias (e.g., `type A = ...`) because conditional types are purely type-level logic; they do not exist at runtime.
Assigning to a type alias lets us reference and reuse the result in other type declarations, enabling composable and readable type logic. 
Typically, we use these aliases in further type-level computations or constraints rather than trying to instantiate values of those types, 
since types like true or false from a conditional aren't usually used directly in value-level code. 
In this way, the `type` keyword acts similarly to `const`: it creates an immutable alias in the type system that cannot be reassigned, 
though it has no runtime presence like `const` does.

```ts
type A = { kind: "A" }
type B = { kind: "B" }

type SelectType<T> = T extends string ? A : B

function create<T>(value: T): SelectType<T> {
  return (typeof value === "string"
    ? { kind: "A" }
    : { kind: "B" }) as SelectType<T>
}

const resultString = create("hello") // type A
const resultNumber = create(123)     // type B
console.log(resultString) // { kind: "A" }
console.log(resultNumber) // { kind: "B" }
```

The return type of `create<T>` is defined using the conditional type `SelectType<T>`. 
This type evaluates whether `T` extends `string`. 
If it does, the result is type `A`; otherwise, it is type `B`. 
At runtime, the `create` function performs a corresponding check with `typeof`, returning a structure that matches the expected type.

### Using `infer` to Extract Types

The `infer` keyword introduces a type variable to be inferred in a conditional type:

```ts
type ElementType<T> = T extends (infer U)[] ? U : T

// Usage:
type TestArray = ElementType<string[]>   // string
type TestPrimitive = ElementType<number> // number
```

- `T extends (infer U)[]` checks whether the type `T` is assignable to an array type.
- If `T` is an array type, `infer U` extracts the element type of that array and returns it.
- If `T` is not an array type, it simply returns `T` itself.

You can use `infer` to extract argument types from functions:

```ts
type ArgumentType<T> = T extends (arg: infer A) => any ? A : never

type Fn = (x: boolean) => void
type Arg = ArgumentType<Fn>  // boolean
```

And multiple parameters:

```ts
type ParametersOf<T> = T extends (...args: infer P) => any ? P : never

type MyFn = (x: string, y: number) => void
type Params = ParametersOf<MyFn>  // [string, number]
```

### Recursive Conditional Types

Conditional types can be recursive, enabling powerful type-level computations:

```ts
type Flatten<T> = T extends (infer U)[] ? Flatten<U> : T

type NestedArray = number[][][]
type FlatType = Flatten<NestedArray>  // number
```

Recursive types are useful for deeply nested structures or list processing.

## Template Literal Types

Template literal types enable constructing new string literal types by concatenating or interpolating string literals:

```ts
// Combine literal types:
type Lang = "en" | "fr"
type FileExtension = ".json" | ".txt"
type Filename = `${Lang}${FileExtension}`

const file: Filename = "en.json" // OK
```

You can use `infer` and `extends` with template literals to extract and manipulate parts of string types:

```ts
type ExtractLang<T> = T extends `${infer L}.${string}` ? L : never

type Lang1 = ExtractLang<"en.json"> // "en"
type Lang2 = ExtractLang<"fr.txt">  // "fr"
```

This allows the type system to analyze string structures at compile time.

## `keyof` and Indexed Access Types

The `keyof` operator produces a union of the keys of a type:

```ts
type Person = {
  name: string
  age: number
}

type PersonKeys = keyof Person // "name" | "age"
```

You can access the type of a specific property using indexed access:

```ts
type AgeType = Person["age"] // number
```

If used with `keyof`, you can define generic utility types:

```ts
type ValueOf<T> = T[keyof T]
type PersonValues = ValueOf<Person> // string | number
```

## `typeof` and `as const`

You can use `typeof` to get the type of a value:

```ts
const config = {
  host: "localhost",
  port: 8080
}

type ConfigType = typeof config
// Equivalent to:
// type ConfigType = { host: string; port: number }
```

When combined with `as const`, you can preserve literal types:

```ts
const status = {
  loading: "loading",
  success: "success"
} as const

type Status = typeof status[keyof typeof status] // "loading" | "success"
```

Without `as const`, the values would widen to `string`.
With `as const`, they retain their literal values.

## Mapped Types

Mapped types transform all the properties of an existing type, using an _index signature_ as introduced in Chapter 2.3:

```ts
type Options = {
  darkMode: boolean
  fontSize: number
}

type PartialOptions = {
  [K in keyof Options]?: Options[K]
}
```

- `keyof Options` produces a union of the keys of the `Options` type (e.g., `"darkMode" | "fontSize"`).
- `K in keyof Options` iterates over each of those keys.
- The `?` makes each key optional.
- `Options[K]` is the type of the corresponding property.

In essence, this creates a new type with all the same keys as Options, but where each property is optional and retains the original type.
This creates a type where all properties of `Options` are optional:

```ts
// PartialOptions is equivalent to:
type PartialOptions = {
  darkMode?: boolean
  fontSize?: number
}
```

### Predefined Mapped Types

TypeScript provides a set of built-in mapped types that are globally available and do not require explicit import. 

| Utility Type               | Description                                                                          |
|----------------------------|--------------------------------------------------------------------------------------|
| `Partial<T>`               | Makes all properties in `T` optional.                                                |
| `Required<T>`              | Makes all properties in `T` required (removes optional `?`).                         |
| `Readonly<T>`              | Makes all properties in `T` readonly.                                                |
| `Pick<T, K>`               | Selects a subset of properties from `T` specified by `K`.                            |
| `Omit<T, K>`               | Removes a subset of properties from `T` specified by `K`.                            |
| `Record<K, T>`             | Constructs an object type with keys of `K` and values of type `T`.                   |

Here are definitions of some of the most widely used built-in mapped types:

```ts
type MyPartial<T> = {
  [P in keyof T]?: T[P]
}

type MyReadonly<T> = {
  readonly [P in keyof T]: T[P]
}

type MyRequired<T> = {
  [P in keyof T]-?: T[P]
}

// Example usage
type User = { name: string; age?: number }
type PartialUser = MyPartial<User>     // { name?: string; age?: number }
type RequiredUser = MyRequired<User>   // { name: string; age: number }
type ReadonlyUser = MyReadonly<User>   // { readonly name: string; readonly age?: number }
```

The `-` in this context _removes the modifier_.
Here, `-?` removes the optional modifier, making each property required, and `-readonly` removes the `readonly` modifier, making properties mutable.

You can combine modifiers:

```ts
type FullyMutable<T> = {
  -readonly [P in keyof T]-?: T[P]
}
```

## Key Remapping and Filtering

You can remap keys using mapped types:

```ts
type PrefixKeys<T> = {
  [K in keyof T as `prefix_${string & K}`]: T[K]
}

// Example:
type Input = { name: string; age: number }
type Prefixed = PrefixKeys<Input>
// { prefix_name: string; prefix_age: number }
```

You can also filter keys:

```ts
type OnlyStrings<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K]
}

// Example:
type Mixed = { a: string; b: number; c: string }
type StringsOnly = OnlyStrings<Mixed>
// { a: string; c: string }
```

For each key, if the property's type `T[K]` extends `string`, it keeps `K` in the result.
Otherwise, it maps `K` to `never`, which effectively removes that key from the resulting type.
Thus, it filters the keys of `T` based on whether their values are of type `string`.

## Template Literal Types with Mapped Types

You can use template literals to create new key names:

```ts
type EventHandlers<T> = {
  [K in keyof T & string as `on${Capitalize<K>}`]: () => void
}

// Example:
type UI = { click: boolean; focus: boolean }
type Handlers = EventHandlers<UI>
// { onClick: () => void; onFocus: () => void }
```

## Conditional Logic in Mapped Types

Conditional logic can be used inside mapped types.
Here, we make an object's fields nullable in a type-safe way while preserving fields that are already explicitly nullable:

```ts
type NullableFields<T> = {
  [K in keyof T]: null extends T[K] ? T[K] : T[K] | null
}

// Example:
type Person = { name: string; bio: string | null }
type WithNullable = NullableFields<Person>
// { name: string | null; bio: string | null }
```

- `K in keyof T` iterates over all keys `K` of the object type `T`.
- `null extends T[K]` checks whether the type of the property `T[K]` already includes `null`.
- `? T[K] : T[K] | null` means that if `T[K]` already allows `null`, leave it unchanged. Otherwise, add `null` to the union.

This results in a type where every property becomes nullable unless it was already nullable.
