# Functions and Signatures

In TypeScript, functions serve as first-class values with precisely described input and output types.
Type signatures provide more than documentation—the compiler checks them, preventing errors, and clarifying intent.
Understanding TypeScript's function system requires grasping how different declaration styles, parameter patterns, and type annotations work together.

## Function Declarations vs Expressions

TypeScript supports multiple ways to declare functions, each with distinct characteristics:

### Function Declarations

```ts
function greet(name: string): string {
  return `Hello, ${name}!`
}
```

Function declarations get hoisted to the top of their scope, meaning you can call them before their declaration appears in the code:

```ts
console.log(add(2, 3)) // Works: prints 5

function add(x: number, y: number): number {
  return x + y
}
```

### Function Expressions

```ts
const greet = function(name: string): string {
  return `Hello, ${name}!`
}
```

Function expressions behave like any other variable assignment—they're not hoisted and must be declared before use:

```ts
console.log(add(2, 3)) // Error: Cannot access 'add' before initialization

const add = function(x: number, y: number): number {
  return x + y
}
```

### Arrow Functions

```ts
const greet = (name: string): string => `Hello, ${name}!`
```

Arrow functions provide concise syntax and lexical `this` binding.
They work best for short functions and callbacks:

```ts
const numbers = [1, 2, 3, 4, 5]
const doubled = numbers.map(n => n * 2)
const evens = numbers.filter(n => n % 2 === 0)
```

For multi-line arrow functions, use block syntax:

```ts
const processUser = (user: User): ProcessedUser => {
  const validated = validateUser(user)
  const normalized = normalizeUser(validated)
  return transformUser(normalized)
}
```

### When to Use Each Style

- **Function declarations**: Use for top-level functions, especially when you need hoisting or recursive functions
- **Function expressions**: Use when you need to conditionally create functions or pass them as values
- **Arrow functions**: Use for callbacks, short utilities, and when you need lexical `this` binding

## Parameters

TypeScript supports various parameter patterns that enhance function flexibility and type safety.

### Required Parameters

```ts
function divide(dividend: number, divisor: number): number {
  return dividend / divisor
}
```

All parameters are required by default.
Calling the function with missing arguments produces a compile-time error:

```ts
divide(10) // Error: Expected 2 arguments, but got 1
```

### Optional Parameters

Add `?` to make parameters optional:

```ts
function log(message: string, userId?: string): void {
  if (userId) {
    console.log(`[${userId}] ${message}`)
  } else {
    console.log(message)
  }
}

log("System started") // OK
log("User logged in", "user123") // OK
```

Optional parameters must follow required parameters:

```ts
function bad(optional?: string, required: number) {} // Error
function good(required: number, optional?: string) {} // OK
```

### Default Parameters

Provide default values for parameters:

```ts
function greet(name = "Guest"): string {
  return `Hello, ${name}`
}

greet() // "Hello, Guest"
greet("Alice") // "Hello, Alice"
```

You can combine default parameters with explicit types:

```ts
function createUser(name: string, role: string = "user", active: boolean = true) {
  return { name, role, active }
}
```

Default parameters automatically become optional, so you don't need the `?`:

```ts
// These are equivalent:
function greet1(name: string = "Guest"): string { return `Hello, ${name}` }
function greet2(name?: string): string { return `Hello, ${name || "Guest"}` }
```

### Rest Parameters

Rest parameters collect multiple arguments into an array:

```ts
function sum(...values: number[]): number {
  return values.reduce((total, value) => total + value, 0)
}

sum(1, 2, 3) // 6
sum(10, 20, 30, 40) // 100
```

You can combine rest parameters with regular parameters, but rest parameters must come last:

```ts
function logWithLevel(level: string, ...messages: string[]): void {
  console.log(`[${level}]`, ...messages)
}

logWithLevel("INFO", "System", "started", "successfully")
// Output: [INFO] System started successfully
```

Rest parameters work with different types:

```ts
function createRecord<T>(id: string, ...data: T[]): Record<string, T[]> {
  return { [id]: data }
}

const userRecord = createRecord("users", "Alice", "Bob", "Charlie")
// { users: ["Alice", "Bob", "Charlie"] }
```

## Function Types

Function types describe the shape of functions, including parameter types and return types.

### Basic Function Types

```ts
type MathOperation = (x: number, y: number) => number
type StringProcessor = (input: string) => string
type Predicate<T> = (value: T) => boolean
```

Use these types to annotate variables or parameters:

```ts
const add: MathOperation = (x, y) => x + y
const multiply: MathOperation = (x, y) => x * y

function applyOperation(op: MathOperation, a: number, b: number): number {
  return op(a, b)
}

const result = applyOperation(multiply, 5, 3) // 15
```

### Function Types with Optional Parameters

```ts
type Logger = (message: string, level?: string) => void

const consoleLogger: Logger = (message, level = "INFO") => {
  console.log(`[${level}] ${message}`)
}
```

### Function Types with Rest Parameters

```ts
type Formatter = (template: string, ...args: unknown[]) => string

const formatter: Formatter = (template, ...args) => {
  return template.replace(/{(\d+)}/g, (match, index) => {
    return String(args[parseInt(index)] ?? match)
  })
}

formatter("Hello {0}, you have {1} messages", "Alice", 5)
// "Hello Alice, you have 5 messages"
```

### Higher-Order Function Types

Functions that accept or return other functions:

```ts
type Transform<T, U> = (value: T) => U
type Composer = <A, B, C>(f: Transform<B, C>, g: Transform<A, B>) => Transform<A, C>

const compose: Composer = (f, g) => (value) => f(g(value))

const addOne = (x: number) => x + 1
const double = (x: number) => x * 2
const addOneThenDouble = compose(double, addOne)

console.log(addOneThenDouble(3)) // 8 (3 + 1 = 4, then 4 * 2 = 8)
```

## Overloads

Function overloads define multiple signatures for the same function, enabling precise typing for functions that behave differently based on their arguments.

### Basic Overloads

```ts
function makeDate(timestamp: number): Date
function makeDate(year: number, month: number, day: number): Date
function makeDate(a: number, b?: number, c?: number): Date {
  if (b !== undefined && c !== undefined) {
    return new Date(a, b - 1, c) // month is 0-indexed
  }
  return new Date(a)
}

const date1 = makeDate(1640995200000) // from timestamp
const date2 = makeDate(2024, 1, 15)   // from year, month, day
```

The implementation signature (the one with the function body) must be compatible with all overload signatures, but callers only see the overload signatures.

### Overloads with Different Return Types

```ts
function getValue(key: "count"): number
function getValue(key: "name"): string
function getValue(key: "active"): boolean
function getValue(key: string): number | string | boolean {
  const config = {
    count: 42,
    name: "TypeScript",
    active: true
  }
  return config[key as keyof typeof config]
}

const count = getValue("count")   // TypeScript knows this is number
const name = getValue("name")     // TypeScript knows this is string
const active = getValue("active") // TypeScript knows this is boolean
```

### Overloads vs. Union Types

Sometimes union types provide a simpler alternative to overloads:

```ts
// Using overloads (more verbose):
function process(input: string): string
function process(input: number): number
function process(input: string | number): string | number {
  return typeof input === "string" ? input.toUpperCase() : input * 2
}

// Using union types (simpler):
function process(input: string | number): string | number {
  return typeof input === "string" ? input.toUpperCase() : input * 2
}
```

Use overloads when you need precise return type relationships.
Use union types when the relationship is simpler.

### Practical Overload Example

```ts
interface User {
  id: number
  name: string
  email: string
}

// Find by ID
function findUser(id: number): Promise<User | null>
// Find by email
function findUser(email: string): Promise<User | null>
// Find by partial match
function findUser(criteria: Partial<User>): Promise<User[]>
// Implementation
function findUser(
  criteria: number | string | Partial<User>
): Promise<User | User[] | null> {
  if (typeof criteria === "number") {
    return findById(criteria)
  }
  if (typeof criteria === "string") {
    return findByEmail(criteria)
  }
  return findByPartial(criteria)
}

// Usage shows clear intent:
const userById = await findUser(123)           // Promise<User | null>
const userByEmail = await findUser("a@b.com")  // Promise<User | null>
const users = await findUser({ name: "Alice" }) // Promise<User[]>
```

## `this` in Functions

The `this` keyword behaves differently in TypeScript depending on how you declare and call functions.

### `this` in Regular Functions

In regular functions, `this` depends on how the function gets called:

```ts
const user = {
  name: "Alice",
  greet() {
    return `Hello, I'm ${this.name}`
  }
}

console.log(user.greet()) // "Hello, I'm Alice"

const greetFn = user.greet
console.log(greetFn()) // "Hello, I'm undefined" (this is lost)
```

### `this` in Arrow Functions

Arrow functions capture `this` from their surrounding context:

```ts
const user = {
  name: "Alice",
  greet: () => {
    return `Hello, I'm ${this.name}` // `this` refers to outer scope, not user
  }
}

console.log(user.greet()) // "Hello, I'm undefined"
```

This makes arrow functions ideal for callbacks where you want to preserve the outer `this`:

```ts
class Timer {
  private count = 0
  
  start() {
    // Arrow function preserves `this` from the Timer instance
    setInterval(() => {
      this.count++
      console.log(`Count: ${this.count}`)
    }, 1000)
  }
}
```

### Typing `this` Parameters

TypeScript explicitly types the `this` context using a special first parameter:

```ts
interface Database {
  query(sql: string): any[]
}

function executeQuery(this: Database, sql: string): any[] {
  return this.query(sql)
}

const db: Database = {
  query(sql: string) {
    console.log(`Executing: ${sql}`)
    return []
  }
}

// Must call with correct `this` context:
executeQuery.call(db, "SELECT * FROM users") // OK
executeQuery("SELECT * FROM users") // Error: The 'this' context is missing
```

### `this` in Class Methods

Class methods automatically bind `this` to the instance:

```ts
class Calculator {
  private result = 0
  
  add(value: number) {
    this.result += value
    return this
  }
  
  multiply(value: number) {
    this.result *= value
    return this
  }
  
  getValue() {
    return this.result
  }
}

const calc = new Calculator()
const result = calc.add(5).multiply(2).getValue() // 10
```

### Binding Methods

When you need to pass methods around, use explicit binding:

```ts
class EventHandler {
  private count = 0
  
  handleClick() {
    this.count++
    console.log(`Clicked ${this.count} times`)
  }
  
  setup() {
    // Bind the method to preserve `this`
    document.addEventListener("click", this.handleClick.bind(this))
    
    // Or use an arrow function
    document.addEventListener("click", () => this.handleClick())
  }
}
```

## `void` vs `undefined`

Understanding the difference between `void` and `undefined` helps you write clearer function signatures.

### When to Use `void`

Use `void` for functions that don't return a meaningful value:

```ts
function logMessage(message: string): void {
  console.log(message)
  // No explicit return, or return without value
}

function processAsync(data: unknown[]): void {
  data.forEach(item => {
    // Process each item
    console.log(item)
  })
  return // OK: returning nothing from void function
}
```

### When to Use `undefined`

Use `undefined` when the function explicitly returns `undefined` as a meaningful value:

```ts
function findItem<T>(items: T[], predicate: (item: T) => boolean): T | undefined {
  for (const item of items) {
    if (predicate(item)) {
      return item
    }
  }
  return undefined // Explicit return of undefined
}

// The return type clearly shows undefined is a possible outcome
const user = findItem(users, u => u.id === 123) // User | undefined
```

### The Practical Difference

```ts
// void functions can return undefined, but callers shouldn't use the result
const voidFn = (): void => {
  return undefined // OK
}

const result1 = voidFn() // result1 has type void (not useful)

// undefined functions explicitly return undefined as a value
const undefinedFn = (): undefined => {
  return undefined // Required
}

const result2 = undefinedFn() // result2 has type undefined (can be checked)

if (result2 === undefined) {
  // This check makes sense
}
```

### `void` in Function Types

`void` in function types allows the function to return anything, but the caller ignores the return value:

```ts
type EventHandler = () => void

const handler1: EventHandler = () => {
  return "some value" // OK: return value is ignored
}

const handler2: EventHandler = () => {
  console.log("handling event")
  // No return statement - also OK
}

// Both work as event handlers because the return value is ignored
document.addEventListener("click", handler1)
document.addEventListener("click", handler2)
```

This flexibility makes `void` perfect for callback types where you don't care what the function returns, only that it gets called.

## Function Signature Best Practices

### Prefer Specific Types Over Generic Ones

```ts
// Less specific:
function processData(data: any): any {
  return data.map((item: any) => item.value)
}

// More specific:
function processData<T extends { value: unknown }>(data: T[]): unknown[] {
  return data.map(item => item.value)
}

// Even better with concrete types when possible:
function processUsers(users: User[]): string[] {
  return users.map(user => user.name)
}
```

### Use Overloads for Complex APIs

When a function behaves very differently based on its parameters, overloads clarify intent:

```ts
function configure(options: string): Configuration
function configure(options: ConfigObject): Configuration
function configure(key: string, value: unknown): Configuration
function configure(...args: unknown[]): Configuration {
  // Implementation handles all cases
}
```

### Design for Immutability

Prefer functions that don't mutate their inputs:

```ts
// Mutating (less predictable):
function addToList<T>(list: T[], item: T): void {
  list.push(item)
}

// Non-mutating (more predictable):
function addToList<T>(list: readonly T[], item: T): T[] {
  return [...list, item]
}
```

### Use Descriptive Parameter Names

Parameter names serve as documentation:

```ts
// Unclear:
function calculate(a: number, b: number, c: boolean): number

// Clear:
function calculateTotal(subtotal: number, taxRate: number, includeTax: boolean): number
```

Understanding TypeScript's function system enables you to write clear, type-safe code that expresses intent precisely.
The combination of proper parameter patterns, accurate return types and thoughtful use of `this` creates functions that both humans and compilers can understand reliably.