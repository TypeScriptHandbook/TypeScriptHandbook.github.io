# Keywords and Operators

JavaScript and TypeScript share a common foundation of keywords and operators, but TypeScript extends this foundation with additional type-level constructs.
Understanding how these elements work together helps you navigate the language's evolution from dynamic scripting to statically typed development.

## The Evolution of Variable Declarations

JavaScript's approach to variable declarations reflects its evolution from a simple scripting language to a robust application platform. 
This evolution created three distinct declaration keywords, each solving different problems.

### The Legacy of `var`

JavaScript originally provided only `var` for variable declarations:

```js
function demo() {
  console.log(x) // undefined (not an error!)
  var x = 5
  console.log(x) // 5
}
```

This behavior, called *hoisting*, moves variable declarations to the top of their function scope during compilation. 
The declaration gets hoisted, but the assignment stays in place:

```js
// JavaScript internally rewrites the above as:
function demo() {
  var x // hoisted declaration
  console.log(x) // undefined
  x = 5 // assignment remains here
  console.log(x) // 5
}
```

Function-scoped variables created confusion in block-structured code:

```js
function processItems() {
  for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100) // Always prints 3!
  }
  console.log(i) // 3 (i leaked out of the loop)
}
```

### Modern Block Scoping

ES6 introduced `let` and `const` to provide block scoping:

```js
function processItems() {
  for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100) // Prints 0, 1, 2
  }
  // console.log(i) // Error: i is not defined outside the loop
}
```

`let` creates mutable block-scoped variables:

```js
let count = 1
count++ // OK
if (true) {
  let count = 10 // Different variable, shadows outer count
  console.log(count) // 10
}
console.log(count) // 2
```

`const` creates immutable bindings for primitive values:

```js
const name = "Alice"
// name = "Bob" // Error: Cannot assign to const variable
```

For objects, `const` prevents reassignment but JavaScript allows mutation:

```js
const user = { name: "Alice", age: 30 }
user.age = 31 // OK: mutating the object
// user = { name: "Bob", age: 25 } // Error: cannot reassign
```

## Organizing Code with Functions and Classes

JavaScript supports multiple approaches to organizing reusable code, from simple functions to modern class syntax.

### Function Declarations

Functions serve as the primary unit of code organization:

```ts
function calculateTax(amount: number, rate: number): number {
  return amount * rate
}
```

Function declarations get hoisted, so you can call them before their definition:

```ts
const total = calculateTotal(100, 0.08) // Works

function calculateTotal(subtotal: number, taxRate: number): number {
  return subtotal + calculateTax(subtotal, taxRate)
}

function calculateTax(amount: number, rate: number): number {
  return amount * rate
}
```

### Modern Class Syntax

Classes provide a familiar structure for object-oriented programming:

```ts
class BankAccount {
  private balance: number
  
  constructor(initialBalance: number) {
    this.balance = initialBalance
  }
  
  deposit(amount: number): void {
    this.balance += amount
  }
  
  getBalance(): number {
    return this.balance
  }
}

const account = new BankAccount(1000)
account.deposit(250)
console.log(account.getBalance()) // 1250
```

Classes support inheritance through `extends`:

```ts
class SavingsAccount extends BankAccount {
  private interestRate: number
  
  constructor(initialBalance: number, rate: number) {
    super(initialBalance) // Call parent constructor
    this.interestRate = rate
  }
  
  applyInterest(): void {
    const interest = this.getBalance() * this.interestRate
    this.deposit(interest)
  }
}
```

## TypeScript's Type-Level Keywords

TypeScript extends JavaScript with keywords that exist only during compilation, providing static type checking without runtime overhead.

### Defining Types

`interface` describes the shape of objects:

```ts
interface User {
  id: number
  name: string
  email: string
}

function createUser(userData: User): User {
  return { ...userData, id: Math.floor(Math.random() * 10000) }
}
```

`type` creates type aliases and supports advanced type operations:

```ts
type Status = "pending" | "approved" | "rejected"
type UserWithStatus = User & { status: Status }

type EventHandler<T> = (event: T) => void
```

`enum` defines named constants:

```ts
enum OrderStatus {
  Pending,
  Processing,
  Shipped,
  Delivered
}

function updateOrder(orderId: string, status: OrderStatus): void {
  console.log(`Order ${orderId} is now ${OrderStatus[status]}`)
}
```

### Module System

`import` and `export` organize code across files:

```ts
// user.ts
export interface User {
  id: number
  name: string
}

export function createUser(name: string): User {
  return { id: generateId(), name }
}

// main.ts
import { User, createUser } from "./user"

const newUser: User = createUser("Alice")
```

## Control Flow and Logic

JavaScript provides standard control flow constructs with some unique characteristics worth understanding.

### Conditional Logic

Basic conditionals work as expected:

```ts
function processOrder(order: { status: string }): void {
  if (order.status === "pending") {
    console.log("Validating order...")
  } else if (order.status === "approved") {
    console.log("Fulfilling order...")
  } else {
    console.log(`Unknown status: ${order.status}`)
  }
}
```

`switch` statements enable pattern matching on discrete values:

```ts
type UserAction = 
  | { type: "login"; credentials: string }
  | { type: "logout"; userId: string }
  | { type: "updateProfile"; userId: string; data: any }

function handleUserAction(action: UserAction): void {
  switch (action.type) {
    case "login":
      console.log(`Authenticating with ${action.credentials}`)
      break
    case "logout":
      console.log(`Clearing session for user ${action.userId}`)
      break
    case "updateProfile":
      console.log(`Updating profile for user ${action.userId}`)
      break
    default:
      throw new Error(`Unhandled action: ${action.type}`)
  }
}
```

### Iteration

JavaScript supports multiple iteration patterns:

```ts
const numbers = [1, 2, 3, 4, 5]

// Traditional for loop
for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i])
}

// for...of iterates over values
for (const number of numbers) {
  console.log(number)
}

// for...in iterates over keys (avoid with arrays)
const user = { name: "Alice", age: 30 }
for (const key in user) {
  console.log(`${key}: ${user[key as keyof typeof user]}`)
}

// while and do-while loops
let count = 0
while (count < 5) {
  console.log(count)
  count++
}
```

## Operators and Expressions

JavaScript's operators handle both traditional computations and modern patterns like optional access and nullish coalescing.

### Arithmetic and Assignment

Standard mathematical operations:

```ts
const subtotal = 100
const taxRate = 0.08
const tax = subtotal * taxRate
const total = subtotal + tax

let balance = 1000
balance += 250  // balance = balance + 250
balance *= 1.02 // apply 2% interest
```

### Comparison and Equality

JavaScript provides both loose and strict equality:

```ts
console.log(5 == "5")  // true (type coercion)
console.log(5 === "5") // false (strict equality)

// Always prefer strict equality
function isValidId(id: unknown): id is number {
  return typeof id === "number" && id > 0
}
```

### Logical Operations

Logical operators support both boolean logic and value selection:

```ts
// Add missing helper function
function checkUserPermission(): boolean {
  return Math.random() > 0.5 // Simulate permission check
}

// Boolean logic
const isAuthenticated = true
const hasPermission = checkUserPermission()
const canAccess = isAuthenticated && hasPermission

// Short-circuit evaluation for default values
const user = { name: "", age: 30 }
const username = user.name || "Anonymous"

// Nullish coalescing for more precise defaults
const config = { timeout: 5000 }
const port = config.port ?? 3000 // Only replaces null/undefined, not 0 or ""
```

### Modern Property Access

Optional chaining safely accesses nested properties:

```ts
interface User {
  profile?: {
    address?: {
      street: string
      city: string
    }
  }
}

function getCity(user: User): string | undefined {
  return user.profile?.address?.city
}

// Works with method calls too
user.processPayment?.()
```

### Destructuring and Spread

Destructuring extracts values from objects and arrays:

```ts
const user = { name: "Alice", age: 30, email: "alice@example.com" }
const { name, ...otherProps } = user

const numbers = [1, 2, 3, 4, 5]
const [first, second, ...rest] = numbers
```

Spread syntax expands collections:

```ts
const originalUser = { name: "Alice", age: 30 }
const updatedUser = { ...originalUser, age: 31 }

const moreNumbers = [...numbers, 6, 7, 8]
```

## TypeScript's Advanced Type Operators

TypeScript provides operators that work exclusively at the type level, enabling sophisticated type transformations.

### Type Queries

`typeof` extracts types from values:

```ts
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3
}

type Config = typeof config
// Equivalent to: { apiUrl: string; timeout: number; retries: number }
```

`keyof` extracts property names as a union:

```ts
type ConfigKeys = keyof Config // "apiUrl" | "timeout" | "retries"

function getConfigValue<K extends keyof Config>(key: K): Config[K] {
  return config[key]
}

const url = getConfigValue("apiUrl") // TypeScript knows this is string
```

### Type Assertions and Narrowing

`as` performs type assertions when you know more than TypeScript:

```ts
const element = document.getElementById("myInput") as HTMLInputElement
element.value = "new value" // TypeScript knows this is an input element
```

Type predicates enable custom type narrowing:

```ts
function isString(value: unknown): value is string {
  return typeof value === "string"
}

function processValue(value: unknown): void {
  if (isString(value)) {
    console.log(value.toUpperCase()) // TypeScript knows value is string
  }
}
```

`satisfies` ensures a value matches a type without changing its inferred type:

```ts
type Colors = "red" | "green" | "blue"

const palette = {
  primary: "red",
  secondary: "green",
  accent: "blue"
} satisfies Record<string, Colors>

// palette.primary is still inferred as "red", not Colors
```

## The Versatile Square Bracket

Square brackets serve multiple purposes in JavaScript and TypeScript, making them one of the most context-dependent syntactic elements.

### Runtime Uses

Array literals and indexing:

```ts
const fruits = ["apple", "banana", "cherry"]
const first = fruits[0]
```

Dynamic property access:

```ts
const propertyName = "score"
const user = { name: "Alice", score: 95 }
const value = user[propertyName] // 95
```

### Type-Level Uses

Index signatures describe dynamic property types:

```ts
interface StringDictionary {
  [key: string]: string
}

const translations: StringDictionary = {
  hello: "hola",
  goodbye: "adiós"
}
```

Mapped types transform existing types:

```ts
type Partial<T> = {
  [K in keyof T]?: T[K]
}

type PartialUser = Partial<User>
// All properties become optional
```

Tuple types define fixed-length arrays:

```ts
type Coordinates = [number, number]
type RGB = [red: number, green: number, blue: number]

const point: Coordinates = [10, 20]
const color: RGB = [255, 128, 0]
```

## Error Handling and Control Transfer

JavaScript provides structured error handling and early exit mechanisms.

### Exception Handling

```ts
async function fetchUserData(id: string): Promise<User> {
  try {
    const response = await fetch(`/api/users/${id}`)
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }
    return await response.json()
  } catch (error) {
    console.error("Failed to fetch user:", error)
    throw error // Re-throw for caller to handle
  } finally {
    console.log("Fetch attempt completed")
  }
}
```

### Early Exit

`return` exits functions early:

```ts
function processUser(user: { isActive: boolean }): void {
  if (!user.isActive) {
    return // Early exit for inactive users
  }
  // Continue processing active user
  console.log("Updating last seen...")
  console.log("Sending welcome email...")
}
```

`break` and `continue` control loop execution:

```ts
function findFirstEven(numbers: number[]): number | undefined {
  for (const num of numbers) {
    if (num % 2 !== 0) {
      continue // Skip odd numbers
    }
    if (num > 100) {
      break // Stop if we find a large even number
    }
    return num // Return first small even number
  }
  return undefined
}
```

## Bringing It All Together

These keywords and operators work together to create expressive, type-safe code. Modern TypeScript development combines JavaScript's runtime flexibility with compile-time guarantees:

```ts
interface DatabaseConnection {
  connect(): void
}

class DatabaseConnection {
  constructor(private config: any) {}
  connect(): void {
    console.log("Connected to database")
  }
}

// Type-safe configuration with runtime validation
interface DatabaseConfig {
  host: string
  port: number
  ssl: boolean
  credentials?: {
    username: string
    password: string
  }
}

function createConnection(config: DatabaseConfig): DatabaseConnection {
  // Runtime validation
  if (!config.host || config.port <= 0) {
    throw new Error("Invalid database configuration")
  }
  
  // Safe property access with defaults
  const connectionString = `${config.host}:${config.port}`
  const useSSL = config.ssl ?? false
  const auth = config.credentials && {
    user: config.credentials.username,
    pass: config.credentials.password
  }
  
  // Type-safe object construction
  return new DatabaseConnection({
    connectionString,
    ssl: useSSL,
    ...auth && { authentication: auth }
  })
}
```

Understanding how JavaScript's foundational elements combine with TypeScript's type system enables you to write code that is both expressive at runtime and safe at compile time.
The key lies in recognizing which constructs serve runtime behavior, which provide compile-time safety, and how they complement each other in building robust applications.