# Type Fundamentals

Building on the JavaScript foundations from Chapter 2, TypeScript adds a sophisticated type system that provides compile-time safety without changing runtime behavior.
This chapter explores how TypeScript's type system models JavaScript's runtime behavior while adding powerful features for catching errors and improving code quality during development.

Every JavaScript feature from Chapter 2 works identically in TypeScript, but TypeScript adds type annotations, inference, and advanced type constructs that disappear after compilation.
Understanding this relationship—how types describe runtime behavior—is fundamental to effective TypeScript development.

## TypeScript's Role: Describing JavaScript

TypeScript's type system mirrors and describes the JavaScript runtime types we covered in Chapter 2.
The seven primitive types from JavaScript become the foundation of TypeScript's type system:

```ts
let str: string = "hello"      // Describes JavaScript's string type
let num: number = 42           // Describes JavaScript's number type  
let bool: boolean = true       // Describes JavaScript's boolean type
let big: bigint = 123n         // Describes JavaScript's bigint type
let sym: symbol = Symbol("s")  // Describes JavaScript's symbol type
let undef: undefined = undefined // Describes JavaScript's undefined type
let nul: null = null           // Describes JavaScript's null type
```

The key insight: these type annotations (`: string`, `: number`, etc.) are TypeScript additions that help during development but don't exist at runtime. The actual values (`"hello"`, `42`, `true`) are pure JavaScript.

### Type Annotations and Inference

TypeScript provides two ways to establish types: explicit annotations or automatic inference.

Explicit annotations:

```ts
let userName: string = "Alice"
let userAge: number = 30
let isActive: boolean = true
```

Type inference (TypeScript deduces the types):

```ts
let userName = "Alice"     // inferred as string
let userAge = 30           // inferred as number
let isActive = true        // inferred as boolean
```

TypeScript's inference is excellent, so explicit annotations are often unnecessary.
The key is understanding when inference needs help and when explicit annotations improve code clarity.

### How TypeScript Enhances Variable Declarations

As we saw in Chapter 2, `const` and `let` are JavaScript features that control variable binding and scoping.
TypeScript adds crucial type inference behavior on top:

```ts
const currentMood = "happy"       // TypeScript infers: "happy" (literal type)
let loadingStatus = "loading"     // TypeScript infers: string (general type)
```

The difference matters for type safety:

- With `const`, TypeScript preserves the exact literal type `"happy"` because the value cannot change
- With `let`, TypeScript generalizes to `string` to allow any string reassignment

This enables powerful type patterns:

```ts
const theme = "dark"  // Type: "dark" - can be used in literal unions
let mode = "dark"     // Type: string - too general for literal unions

type Theme = "light" | "dark"
let selectedTheme: Theme = theme  // ✓ OK - "dark" is assignable to Theme
// let selectedMode: Theme = mode    // ✗ Error - string is not assignable to Theme
```

At runtime: Both variables hold the same string `"dark"`  
At compile-time: The `const` version has a more specific type for better type checking

### Arrays and Objects with Types

TypeScript describes JavaScript's arrays and objects with type information:

Arrays use the `T[]` syntax (preferred) or `Array<T>`:

```ts
let numbers: number[] = [1, 2, 3]        // Preferred modern syntax
let matrix: number[][] = [[1, 2], [3, 4]] // Nested arrays

// Alternative syntax (less common)
let moreNumbers: Array<number> = [4, 5, 6]

// TypeScript infers array types from content
let fruits = ["apple", "banana"]  // inferred as string[]
```

The `number[]` syntax is preferred because it's more concise, reads naturally with array literals, and handles nested arrays cleanly (`number[][]` vs `Array<Array<number>>`).

Object type literals describe structure:

```ts
let user: { name: string; age: number } = {
  name: "Alice",
  age: 30
}

// TypeScript infers object types from structure
let product = {
  id: 1,
  name: "Widget"
}  // inferred as { id: number; name: string }
```

### Type Assertions: When You Know More

Sometimes you know more about a type than TypeScript can infer.
Type assertions tell TypeScript "trust me, I know what this is":

```ts
// Getting an element from the DOM
let userInput: unknown = getUserInput()
let userName = userInput as string  // asserting it's a string

// DOM elements often need assertions
const inputElement = document.getElementById("myInput") as HTMLInputElement
inputElement.value = "new value" // TypeScript now knows this has a value property
```

Type assertions don't perform runtime checks—if you're wrong, your code might break at runtime.

In React projects using `.jsx` or `.tsx` files, always use the `as` syntax instead of `<type>` assertions, since `<type>` conflicts with JSX element syntax.

## Literal Types and Unions

TypeScript can create types representing exact values, not just general categories.
This builds on JavaScript's actual values to create precise type constraints.

### String, Number, and Boolean Literals

```ts
let direction: "left" | "right" | "center" = "left"
let statusCode: 200 | 404 | 500 = 200
let isComplete: true = true  // only accepts true, not false
```

Literal types are much more specific than their general counterparts (`string`, `number`, `boolean`).
They create compile-time guarantees about exact values while the runtime behavior remains unchanged.

### Union Types with `|`

The `|` operator creates union types that accept values of multiple types:

```ts
let id: string | number = "user-123"
id = 456  // also valid

function displayResult(result: string | boolean) {
  if (typeof result === "string") {
    console.log(`Message: ${result}`)
  } else {
    console.log(`Success: ${result}`)
  }
}
```

Notice how we used JavaScript's `typeof` operator (from Chapter 2) within TypeScript code—TypeScript understands JavaScript's runtime type checking and uses it for type narrowing.

### Discriminated Unions: Modeling Complex Data

Literal types enable discriminated unions—a powerful pattern for modeling data that can take different forms:

```ts
type LoadingState = { status: "loading" }
type SuccessState = { status: "success"; data: string }
type ErrorState = { status: "error"; message: string }
type ApiState = LoadingState | SuccessState | ErrorState

function handleApiState(state: ApiState) {
  switch (state.status) {
    case "loading":
      console.log("Loading...")
      break
    case "success":
      console.log(state.data) // TypeScript knows this is SuccessState
      break
    case "error":
      console.error(state.message) // TypeScript knows this is ErrorState
      break
  }
}
```

This uses JavaScript's `switch` statement (from Chapter 2) while TypeScript provides compile-time guarantees that all cases are handled and properties are correctly accessed.

## Special TypeScript Types

TypeScript includes several types that don't exist in JavaScript but solve common programming challenges.

### `any` - The Escape Hatch

The `any` type disables TypeScript's type checking entirely:

```ts
let data: any = 123
data.toUpperCase() // no error, even though numbers don't have toUpperCase()
data = "hello"
data = true
data = { anything: "goes" }
```

Use `any` when:

- Migrating JavaScript code to TypeScript gradually
- Working with dynamic content where types genuinely can't be known
- Interfacing with poorly-typed third-party libraries

Avoid `any` because it defeats TypeScript's purpose.
Use it sparingly with a plan to replace it with proper types.

### `unknown` - The Safe Alternative

Like `any`, you can assign anything to `unknown`, but you must narrow the type before using it:

```js
function getRandomValue() {
  return Math.random() > 0.5 ? "hello" : 42
}
```

In TypeScript, you can safely handle this with `unknown`:

```ts
function getRandomValue(): unknown {
  return Math.random() > 0.5 ? "hello" : 42
}

let userInput: unknown = getRandomValue()

// Must check the type before using
if (typeof userInput === "string") {
  console.log(userInput.toUpperCase()) // ✓ Safe!
}

// ✗ Error: Object is of type 'unknown'
// console.log(userInput.toUpperCase())
```

This combines JavaScript's `typeof` operator with TypeScript's type system for safe dynamic typing.

### `void` - No Return Value

A `void` return type means the function doesn't return a meaningful value:

```ts
function displayMessage(message: string): void {
  console.log(message)
  // implicitly returns undefined
}

function logError(error: string): void {
  console.error(error)
  return // explicitly return nothing
}
```

Functions with `void` return type can return `undefined` explicitly, but callers should ignore the return value.

### `never` - Values That Never Occur

The `never` type represents values that should never exist:

```ts
function throwError(message: string): never {
  throw new Error(message)
  // This function never returns normally
}

function infiniteLoop(): never {
  while (true) {
    // This function never terminates
  }
}
```

TypeScript uses `never` in exhaustive checks and to represent impossible states.
It's more common in advanced type programming than everyday code.

## Immutability in TypeScript's Type System

TypeScript provides several ways to express immutability at the type level, complementing JavaScript's runtime immutability features from Chapter 2.

### The `readonly` Modifier

`readonly` is a TypeScript-only feature that prevents modification at the type level:

In interfaces and type definitions:

```ts
interface User {
  readonly id: number;
  name: string;
  readonly createdAt: Date;
}
```

In object type literals:

```ts
let config: { readonly apiUrl: string; timeout: number } = {
  apiUrl: "https://api.example.com",
  timeout: 5000
}
// config.apiUrl = "https://other.com"; // ✗ Error: Cannot assign to readonly property
config.timeout = 10000; // ✓ Allowed - timeout is not readonly
```

For arrays:

```ts
function processNumbers(numbers: readonly number[]) {
  // numbers.push(4); // ✗ Error: Property 'push' does not exist on type 'readonly number[]'
  return numbers.map(n => n * 2); // ✓ Reading is fine
}
```

In class properties:

```ts
class User {
  readonly id: number;
  name: string;
  
  constructor(id: number, name: string) {
    this.id = id; // ✓ Can set in constructor
    this.name = name;
  }
}
```

### The `as const` Assertion

This creates the most specific possible type for a value, making it deeply immutable at the type level:

```js
// Without 'as const' - types are widened
const colors = ["red", "green", "blue"]; // Type: string[]
const point = { x: 10, y: 20 }; // Type: { x: number; y: number; }
```

With TypeScript's `as const`:

```ts
// With 'as const' - types are narrowed and made readonly
const colorsConst = ["red", "green", "blue"] as const; 
// Type: readonly ["red", "green", "blue"]

const pointConst = { x: 10, y: 20 } as const;
// Type: { readonly x: 10; readonly y: 20; }
```

What `as const` does:

1. _Narrows literal types:_ Instead of `string`, you get `"red"`
2. _Makes arrays readonly tuples:_ `string[]` becomes `readonly ["red", "green", "blue"]`
3. _Makes object properties readonly and literal-typed_
4. _Works recursively on nested structures_

Type-safe constants pattern:

```ts
const STATUS = {
  PENDING: "pending",
  COMPLETED: "completed",
  FAILED: "failed"
} as const;

type Status = typeof STATUS[keyof typeof STATUS]; // "pending" | "completed" | "failed"

function updateStatus(status: Status) {
  // status must be one of the exact string literals
}
```

This pattern uses advanced TypeScript type operators:

- `typeof STATUS` gets the type of the STATUS object
- `keyof typeof STATUS` gets the union of property names: `"PENDING" | "COMPLETED" | "FAILED"`
- `typeof STATUS[keyof typeof STATUS]` gets the union of property values: `"pending" | "completed" | "failed"`

### Combining Compile-time and Runtime Immutability

For actual runtime immutability, use JavaScript's `Object.freeze()` (covered in Chapter 2):

```js
const config = Object.freeze({
  apiUrl: "https://api.example.com",
  timeout: 5000
});
// Now it's runtime immutable
```

Combined with TypeScript:

```ts
const config = Object.freeze({
  apiUrl: "https://api.example.com",
  timeout: 5000
} as const);
// Now it's both compile-time readonly AND runtime immutable
```

### Immutability Feature Comparison

| Feature           | Scope                    | Runtime Effect         | Compile-time Effect                      |
|-------------------|--------------------------|------------------------|------------------------------------------|
| `const`           | Variable binding         | Prevents reassignment  | Preserves literal types                  |
| `readonly`        | Object properties/arrays | None (TypeScript only) | Prevents modification                    |
| `as const`        | Value literals           | None (TypeScript only) | Creates narrowest possible readonly type |
| `Object.freeze()` | Object properties        | Prevents modification  | None (JavaScript only)                   |

## Advanced Type Patterns

### Template Literal Types

TypeScript extends JavaScript's template literals (from Chapter 2) to create compile-time string pattern validation:

```ts
type UserID = `user-${number}`
type ProductID = `product-${number}`

function fetchUser(id: UserID) {
  return `Fetching user with ID: ${id}`
}

fetchUser("user-42")  // ✓ OK
// fetchUser("product-42") // ✗ Error: wrong pattern
```

Combining with unions:

```ts
type SystemRole = "admin" | "editor" | "viewer"
type Permission = `${SystemRole}-access`

const editorPerm: Permission = "editor-access"  // ✓ OK
// const badPerm: Permission = "owner-access"     // ✗ Error: "owner" not in SystemRole
```

API endpoint patterns:

```ts
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE"
type ApiEndpoint = `/${string}`
type ApiCall = `${HttpMethod} ${ApiEndpoint}`

const userEndpoint: ApiCall = "GET /api/users"     // ✓ OK
const createUser: ApiCall = "POST /api/users"      // ✓ OK
// const invalidCall: ApiCall = "PATCH /api"        // ✗ Error: PATCH not allowed
```

This builds on JavaScript's template literal syntax while adding compile-time validation—perfect for APIs, CSS class names, or any domain where string patterns need validation.

### Function Types

Functions have types for their parameters and return values:

```ts
// Function with type annotations
function greet(name: string): string {
  return `Hello, ${name}!`
}

// Arrow function with types (using syntax from Chapter 2)
const add = (a: number, b: number): number => {
  return a + b
}

// Function type annotations
let calculator: (x: number, y: number) => number
calculator = add  // ✓ OK
// calculator = greet  // ✗ Error: parameter types don't match
```

This describes the same arrow function and function declaration syntax from Chapter 2, but with TypeScript's type information added.

### Index Signatures and Mapped Types

TypeScript uses square brackets (which we saw in Chapter 2 for dynamic property access) for type-level operations:

Index signatures describe dynamic property types:

```ts
interface StringDictionary {
  [key: string]: string
}

const translations: StringDictionary = {
  hello: "hola",
  goodbye: "adiós"
}

// This uses the same bracket notation as Chapter 2's dynamic property access
const greeting = translations["hello"] // "hola"
```

Mapped types transform existing types:

```ts
type Partial<T> = {
  [K in keyof T]?: T[K]
}

interface User {
  name: string
  age: number
}

type PartialUser = Partial<User>
// Result: { name?: string; age?: number }
```

Tuple types define fixed-length arrays:

```ts
type Coordinates = [number, number]
type RGB = [red: number, green: number, blue: number]

const point: Coordinates = [10, 20]
const color: RGB = [255, 128, 0]

// These work with JavaScript's array access from Chapter 2
console.log(point[0]) // 10
console.log(color[1]) // 128
```

## Strict Null Checking

With `strictNullChecks` enabled in your TypeScript configuration, `null` and `undefined` become distinct types that must be handled explicitly:

```ts
let name: string = "Alice"
// name = null      // ✗ Error with strictNullChecks
// name = undefined // ✗ Error with strictNullChecks

let optionalName: string | null = "Alice"
optionalName = null  // ✓ OK

let maybeName: string | undefined = "Alice"
maybeName = undefined  // ✓ OK

// Handling nullable values safely
function processName(name: string | null) {
  if (name !== null) {
    console.log(name.toUpperCase()) // TypeScript knows name is string here
  }
}
```

This builds on JavaScript's `null` and `undefined` behavior from Chapter 2, but adds compile-time safety through explicit union types and type narrowing.

### Type Guards and Narrowing

TypeScript understands JavaScript's runtime type checking and uses it for type narrowing:

```ts
function processValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()) // TypeScript knows value is string
  } else {
    console.log(value.toFixed(2)) // TypeScript knows value is number
  }
}
```

Custom type predicates:

```ts
function isString(value: unknown): value is string {
  return typeof value === "string"
}

function handleInput(input: unknown) {
  if (isString(input)) {
    console.log(input.toUpperCase()) // TypeScript knows input is string
  }
}
```

Using JavaScript's `instanceof` operator:

```ts
class ValidationError extends Error {
  constructor(public field: string) {
    super(`Validation failed for ${field}`)
  }
}

function handleError(error: unknown) {
  if (error instanceof ValidationError) {
    console.log(`Field error: ${error.field}`) // TypeScript knows the type
  } else if (error instanceof Error) {
    console.log(`General error: ${error.message}`)
  }
}
```

## Bringing TypeScript and JavaScript Together

Here's an example that shows how TypeScript's type system works with JavaScript's runtime features:

```ts
// TypeScript types describe the shape of JavaScript data
interface DatabaseConfig {
  host: string
  port: number
  ssl?: boolean
  credentials?: {
    username: string
    password: string
  }
}

// Class uses JavaScript features with TypeScript type safety
class DatabaseConnection {
  private config: DatabaseConfig
  private isConnected: boolean = false
  
  constructor(config: DatabaseConfig) {
    // Using spread operator from Chapter 2 with TypeScript types
    this.config = { ...config }
  }
  
  async connect(): Promise<void> {
    try {
      // Destructuring from Chapter 2 with type safety
      const { host, port, credentials } = this.config
      
      if (!host || !port) {
        throw new Error("Missing required connection parameters")
      }
      
      // Optional chaining from Chapter 2 with TypeScript understanding
      const auth = credentials?.username && credentials?.password
        ? { user: credentials.username, pass: credentials.password }
        : null
      
      // Template literals from Chapter 2 with type safety
      const connectionString = `${host}:${port}`
      
      // Simulate async connection using Promises from Chapter 2
      await new Promise(resolve => setTimeout(resolve, 100))
      
      this.isConnected = true
      console.log(`Connected to ${connectionString}`)
    } catch (error) {
      // Error handling from Chapter 2 with TypeScript type narrowing
      if (error instanceof Error) {
        console.error("Connection failed:", error.message)
      }
      throw error
    }
  }
  
  // Generator from Chapter 2 with TypeScript return type annotation
  async *query<T>(sql: string): AsyncGenerator<T, void, unknown> {
    if (!this.isConnected) {
      throw new Error("Not connected to database")
    }
    
    const results = await this.executeQuery<T>(sql)
    
    // for...of loop from Chapter 2 with TypeScript type safety
    for (const row of results) {
      yield row
    }
  }
  
  private async executeQuery<T>(sql: string): Promise<T[]> {
    // Simulate database query
    return [
      { id: 1, name: "Alice" } as T,
      { id: 2, name: "Bob" } as T
    ]
  }
}

// Usage shows JavaScript runtime behavior with TypeScript compile-time safety
async function demonstrateUsage() {
  // Object literal with type checking
  const config: DatabaseConfig = {
    host: "localhost",
    port: 5432,
    credentials: {
      username: "admin",
      password: "secret"
    }
  }
  
  try {
    const db = new DatabaseConnection(config)
    await db.connect()
    
    // for await...of from Chapter 2 with TypeScript type inference
    for await (const row of db.query<{id: number, name: string}>("SELECT * FROM users")) {
      console.log(`User: ${row.name}`) // TypeScript knows row has name property
    }
  } catch (error) {
    // instanceof from Chapter 2 with TypeScript type narrowing
    if (error instanceof Error) {
      console.error("Database operation failed:", error.message)
    }
  }
}
```

## Key Takeaways

1. _TypeScript describes JavaScript:_ Every TypeScript type corresponds to JavaScript runtime behavior—types add compile-time safety without changing execution.

2. _Type inference reduces annotation burden:_ TypeScript's excellent inference means you write fewer type annotations while maintaining safety.

3. _Literal types enable precision:_ Union types, discriminated unions, and template literal types model exact values and complex data structures safely.

4. _Immutability works at multiple levels:_ Combine TypeScript's compile-time `readonly` and `as const` with JavaScript's runtime `Object.freeze()` for comprehensive immutability.

5. _JavaScript and TypeScript complement each other:_ JavaScript's runtime features (from Chapter 2) work seamlessly with TypeScript's compile-time type checking.

6. _Type narrowing leverages JavaScript:_ TypeScript understands JavaScript's `typeof`, `instanceof`, and other runtime checks to provide better type safety.

7. _Advanced patterns solve real problems:_ Template literal types, mapped types, and index signatures enable sophisticated type-level programming for better APIs and fewer bugs.

Understanding how TypeScript's type system describes and enhances JavaScript's runtime behavior enables you to write code that's both expressive at runtime and safe at compile time.
The key is recognizing which constructs serve runtime behavior, which provide compile-time safety, and how they work together to create robust applications.