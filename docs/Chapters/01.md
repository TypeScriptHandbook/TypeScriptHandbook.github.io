# Context and Philosophy

Explaining the reason for TypeScript.
This book assumes you have a firm grasp of at least two programming languages.

## JavaScript: The TypeScript Substrate

If you're coming from a background in strongly typed languages like Java, Rust, C#, or Haskell, JavaScript might initially appear bewildering.
Its loose, dynamic typing, implicit type coercions, and eccentric runtime behaviors seem almost engineered to confuse.
Yet it's precisely this flexibility that made JavaScript successful in its original role as a browser scripting language.

JavaScript was designed in ten days and shipped with only modest expectations.
But through a confluence of historical and economic forces, namely the browser wars and the rise of web applications,
JavaScript became the default language of client-side programming.

Unlike many modern languages, JavaScript evolved through accretion rather than intentional design.
It inherited paradigms from multiple languages: first-class functions from Scheme, prototype-based inheritance from Self, and syntax loosely based on Java.
Over time, these eclectic roots have given it a powerful but chaotic feature set.

Consider the following quirks:

```js
console.log([] + [])  // ""
console.log([] + {})  // "[object Object]"
console.log({} + [])  // 0

console.log(false == 0)   // true
console.log(false === 0)  // false
console.log(NaN === NaN)  // false
console.log(typeof null)  // "object"
```

These examples are not pathological edge cases—they reflect the daily reality of JavaScript developers.

For all its quirks, JavaScript is incredibly expressive and accessible.
The problem is not that it is dynamic, but that it offers no way to constrain or document intent in large systems.
This makes refactoring risky and APIs ambiguous.

## Why TypeScript?

JavaScript's success as the universal scripting language came at a cost: it wasn't designed for scale.
As web applications grew larger and more complex, development teams increasingly needed tools that would:

* Catch errors earlier
* Document contracts between modules
* Enable better IDE support (autocomplete, navigation, refactoring)

TypeScript emerged to meet this need.
Initially conceived by Microsoft as a typed superset of JavaScript, TypeScript introduced a gradual type system that was expressive enough to model most JavaScript idioms without requiring wholesale rewrites.

Instead of replacing JavaScript, TypeScript embraces it.
Any JavaScript file is a valid TypeScript file.
This made adoption incremental and non-disruptive—a crucial factor in its widespread success.

While TypeScript adds structure, it also respects JavaScript's dynamic core.
It does not aim for soundness in the way that languages like Haskell or Rust do.
Its goal is developer productivity, not formal correctness.

In that spirit, this book will assume that you're fluent in at least two programming languages, and want to understand the sometimes beautiful, sometimes bewildering foundations upon which TypeScript is built.

### The Rise of TypeScript

TypeScript was first released in 2012, when JavaScript's limitations were becoming painfully obvious to developers building large-scale applications.
By this point, JavaScript had evolved beyond its origins in front-end scripting to power full client-server applications.
Teams needed better tooling, better guarantees, and better support for maintainable codebases.
JavaScript was flexible, but it wasn't scalable.

Microsoft, with its experience developing languages like C# and managing enormous codebases, saw the opportunity to bring the benefits of static typing to JavaScript.
Rather than creating an entirely new language, they decided to build a superset that extended JavaScript with a powerful optional type system.

### Early Design Goals

From the beginning, TypeScript was designed to be:

* **Gradual**: You could add types where needed, without rewriting existing code
* **Compatible**: All valid JavaScript is valid TypeScript
* **Ergonomic**: Designed with IDE support in mind, with features like intelligent autocomplete, go-to-definition, and real-time error checking

This meant that adopting TypeScript didn't require developers to abandon the JavaScript ecosystem.
TypeScript files could import and export from regular `.js` files and could be incrementally introduced into existing projects.

### Influences and Inspirations

TypeScript was influenced by multiple languages:

* **C#**: TypeScript's syntax and class structure reflect its lineage from C#, which was also designed by Anders Hejlsberg
* **Java**: Interfaces and nominal-looking class hierarchies felt familiar to Java developers
* **ML and Haskell**: TypeScript borrowed advanced type features like discriminated unions and type inference from the functional programming world

Despite these inspirations, TypeScript maintained a distinctly JavaScript sensibility.
It never tried to enforce nominal typing or full runtime safety.
Instead, it focused on offering just enough structure to improve productivity, without fighting the underlying language.

### Widespread Adoption

TypeScript adoption accelerated dramatically once major frameworks and libraries began embracing it.
Angular 2 was one of the first large projects to fully commit to TypeScript.
Later the React ecosystem embraced TypeScript more gradually, but eventually came to treat it as a first-class citizen.

Today many major open-source projects are written in TypeScript, and companies large and small use it to tame complex codebases.

TypeScript has become not just a popular tool but a lens through which many developers now view JavaScript.
It provides a type-safe vocabulary for describing code, enabling collaboration at scale.

By understanding how and why TypeScript was designed, you'll be better prepared to interpret its compromises,
appreciate its expressiveness, and avoid misusing it as a poor approximation of some other language.

TypeScript is not "JavaScript with types." It is a carefully balanced system, designed to improve developer experience while remaining true to its roots.

## Structural Typing vs. Nominal Typing

Most statically typed languages in widespread use, such as Java, C#, C++, Swift, and Rust, are **nominally typed**.
In such languages, type compatibility is based on _names_ and _declarations_.
If you want one type to substitute for another, you must explicitly declare that relationship, often through inheritance or interface implementation.

TypeScript, in contrast, uses _structural typing_, also known as *duck typing*.
If a value has all the required properties and methods, it is considered compatible, regardless of where it came from or what it's named.
Consider the following:

```ts
type Point2D = { x: number; y: number }

function logPoint(p: Point2D) {
  console.log(`${p.x}, ${p.y}`)
}

const coordinates = { x: 10, y: 20, z: 30 }
logPoint(coordinates) // OK! `z` is just extra
```

Even though `coordinates` has an extra `z` property, it's assignable to `Point2D` because it structurally satisfies the requirement.

### The Benefits of Structural Typing

* **Fewer Declarations**: You don't need to formally declare that a class or type implements an interface
* **Flexible API Design**: Callers don't have to extend or import specific types
* **Interoperability**: Easier to integrate third-party code or JSON data

This makes TypeScript feel more "fluid" than other typed languages.
In many cases, this is exactly what you want: minimal ceremony and easy composition.

### The Pitfalls of Structural Typing

The flexibility comes with tradeoffs:

* **Accidental Compatibility**: Two unrelated types with the same shape will be considered compatible
* **Lost Intent**: Without nominal boundaries, it's harder to encode domain distinctions like `UserId` vs `ProductId`
* **Over-permissiveness**: Mistaken types may pass checks if they happen to match structurally

To mitigate these, developers often reach for *branding* techniques to create pseudo-nominal types:

```ts
type UserId = string & { readonly brand: unique symbol }
type ProductId = string & { readonly brand: unique symbol }
```

These types are no longer interchangeable, even though they are both `string` under the hood.
The added "brand" serves as a phantom type to enforce distinction.

### Mental Models for Navigating TypeScript's System

* Think in terms of _shapes_, not class hierarchies
* Use _interfaces_ or _type aliases_ to describe the required structure, not lineage
* Reach for branding or discriminated unions when you need identity, not just structure

TypeScript's structural type system rewards flexibility and expressiveness but requires discipline.
Understanding when to let types flow freely and when to enforce separation is key to writing robust TypeScript code.

If you approach TypeScript expecting nominal rigor, you may find its system too loose.
If you embrace its structural nature while layering your own constraints where needed, you'll find it a powerful ally.