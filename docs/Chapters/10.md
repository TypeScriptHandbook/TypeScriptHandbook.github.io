# Union and Intersection Types

TypeScriptâ€™s type system supports powerful mechanisms for composing types: unions and intersections.
These enable expressive typing strategies for working with different shapes of data.

## Basics

*Union types* represent a value that can be one of several types:

```ts
type Status = "loading" | "success" | "error"

let current: Status = "loading"
current = "success" // OK
current = "done" // Error: not assignable to Status
```

You can also use union types for different shapes:

```ts
type StringOrNumber = string | number

function log(value: StringOrNumber) {
  console.log(value)
}
```

*Intersection types* combine multiple types into a single type that must satisfy all of them:

```ts
type Position = { x: number; y: number }
type Label = { name: string }

type LabeledPoint = Position & Label

const point: LabeledPoint = {
  x: 10,
  y: 20,
  name: "A"
}
```

Use intersections to compose multiple behaviors or responsibilities.

Members of a union or intersection can be primitive types (like `string`, `number`, `boolean`), literal types (like specific strings or numbers), 
object types (including interfaces and type aliases), and even more complex constructs (like unions, intersections, and generics).

```ts
let input: string | number = "hello"
input = 42

interface A { a: number }
interface B { b: string }
type AB = A & B

const value: AB = {
  a: 1,
  b: "text"
}
```

Combining incompatible field definitions in an intersection can lead to the `never` type:

```ts
type A = { value: string }
type B = { value: number }
type C = A & B

// C is inferred as:
// {
//   value: string & number
// }

// Since no value can be both a string and a number at the same time,
// TypeScript reduces this to `never`:
const impossible: C = { value: 42 } // Error
```

Functions and arrays are object types and can also be used in unions or intersections:

```ts
// Union of array and function
let mixed: string[] | (() => string)

mixed = ["a", "b"]
console.log(mixed[0]) // "a"

mixed = () => "hello"
console.log(mixed()) // "hello"

interface Metadata {
  description: string
}

// Intersection of function with object type
type CallableWithMeta = Metadata & ((x: number) => number)

const fn: CallableWithMeta = Object.assign(
  (x: number) => x * 2,
  { description: "doubles the input" }
)


console.log(fn(5)) // 10
console.log(fn.description) // "doubles the input"
```

`Object.assign` combines the callable function and the metadata object into a single value that satisfies both parts of the `CallableWithMeta` type. 
This is a convenient way to create function objects that carry metadata or configuration.

## Discriminated Unions

A discriminated union (also called a tagged union) defines a set of types that share a common property. 
This shared property distinguishes between the individual variants at runtime and during type checking.

```ts
type Circle = {
  kind: "circle"
  radius: number
}

type Square = {
  kind: "square"
  size: number
}

type Shape = Circle | Square

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2
    case "square":
      return shape.size * shape.size
  }
}

const c: Shape = { kind: "circle", radius: 3 }
const s: Shape = { kind: "square", size: 4 }

console.log(area(c)) // 28.274333882308138
console.log(area(s)) // 16
```

Here, `kind` acts as the discriminant. 
Note that the type of `kind` is the literal string `"circle"` for `Circle` and `"square"` for `Square`. 
In this example, `kind` can *only* be initialized to the literal string `"circle"` or `"square"`.

The `switch` statement allows TypeScript to narrow the union to a specific member.

## Exhaustiveness Checks

You can enforce exhaustiveness by ensuring all cases are handled explicitly. 
A common technique is to assign the input to a variable of type `never` in the `default` case:

```ts
function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2
    case "square":
      return shape.size * shape.size
    default:
      const _exhaustiveCheck: never = shape
      return _exhaustiveCheck
  }
}
```

This pattern handles all possible variants of a discriminated union. 
In the `default` case of a `switch` statement, the variable `shape` is assigned to a new variable `_exhaustiveCheck` with the type `never`.

The `never` type in TypeScript represents a value that should never occur.
So if all known cases of the union have been handled above, TypeScript expects the `default` case to be unreachable. 
If a new variant is added to the union and not handled in the `switch`, then `shape` will no longer be of type `never`, and the compiler will generate an error. 
This effectively enforces exhaustive handling of all cases (including for types that are added later).

## Intersection Types

Intersection types combine multiple types into one. 
All properties from all constituent types are required in the result.

```ts
type Person = {
  name: string
}

type Birthdate = {
  birthdate: Date
}

type PersonWithBirthdate = Person & Birthdate

const individual: PersonWithBirthdate = {
  name: "Alice",
  birthdate: new Date("1990-01-01")
}
```

This technique is useful when you want to build up a type with multiple responsibilities. 
For example, you might have a base type for identity and then extend it with additional traits:

```ts
type ContactInfo = {
  email: string
  phone: string
}

type Employee = {
  employeeId: number
  department: string
}

type ContactableEmployee = ContactInfo & Employee

const example: ContactableEmployee = {
  email: "jane@example.com",
  phone: "555-1234",
  employeeId: 456,
  department: "Engineering"
}
```

`ContactableEmployee` must satisfy both the `ContactInfo` and `Employee` types, which illustrates how intersection types let you model composite entities cleanly.

## Common Mistakes and Clarity Techniques

**Mistake: Misusing intersections with overlapping fields.**

```ts
type A = { value: string }
type B = { value: number }
type C = A & B // never usable; incompatible
```

Avoid combining types that define the same field with incompatible types.

**Technique: Use literal types for discriminants.**

Literal string types like `"circle"`, `"square"`, or enums make excellent discriminants for tagged unions.
Consider using `as const` to preserve literal types when defining data structures. For example:

```ts
const shape = {
  kind: "circle",
  radius: 10
} as const
```

Without `as const`, TypeScript might infer `kind` as a general `string` and `radius` as `number`. 
With `as const`, `kind` becomes the literal type `'circle'`, and `radius` becomes the literal `10`. 
This enables precise type inference and is especially useful for discriminated unions.

**Technique: Use type narrowing through control flow.**

TypeScript understands narrowing through `if`, `switch`, and custom type guards.
Prefer `switch` on discriminants for clarity and completeness.
