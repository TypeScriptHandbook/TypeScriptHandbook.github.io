# The JavaScript Object Model

Understanding the JavaScript object model, including prototypes, constructors, and class syntax, 
is essential for working fluently with both JavaScript and TypeScript.

JavaScript uses a _prototype-based_ object model. 
Unlike class-based languages, where classes define inheritance, JavaScript objects inherit from other objects directly. 
This design supports powerful but sometimes non-intuitive behaviors.

## Objects Are Key-Value Maps

In JavaScript, all non-primitive values are objects. 
Objects are collections of properties (keys and values) and can have methods (functions as values).

```ts
// Method shorthand (ES6)
const person1 = {
  name: "Alice",
  greet() {
    // 'this' refers to the 'person1' object:
    return `Hello, I'm ${this.name}` 
  }
}
console.log(person1.greet()) // Hello, I'm Alice

// Traditional function property
const person2 = {
  name: "Bob",
  greet: function () {
    return `Hello, I'm ${this.name}`
  }
}
console.log(person2.greet()) // Hello, I'm Bob

// Arrow function (not recommended for methods)
const person3 = {
  name: "Charlie",
  greet: () => `Hello, I'm ${this?.name}`
}
console.log(person3.greet()) // Hello, I'm undefined
```

This shows the three ways to define methods inside an object:

* **Method shorthand**: The preferred and concise ES6 syntax.
* **Traditional function property**: Fully explicit and works identically.
* **Arrow function**: Inherits `this` from the surrounding context; typically not what you want in object methods.

## Prototypes and Inheritance

Every _function_ in JavaScript is an object.
Regular top-level functions (not arrow functions or methods) each have a default `.prototype` property:

```ts
function greet(name) {
  return `Hello, ${name}`
}

console.log(greet("Alice")) // Hello, Alice

console.log(typeof greet) // function
console.log(greet.prototype) // greet: {} 

const instance = new greet() // TypeError: greet is not a constructor
```

This is different from the function's own prototype (as in `Object.getPrototypeOf(fn)`);
it is instead the object that will be assigned as the `[[Prototype]]` of any instance created using `new`.

```js
function Thing() {}
console.log(typeof Thing.prototype) // "object"
console.log(Thing.prototype.constructor === Thing) // true
```

The prototype is used only when you invoke the function with `new`, to assign as the new object's internal prototype (`[[Prototype]]`).

Classes have prototypes associated with their constructors.
When you use a function as a constructor (via `new`), the resulting object's prototype is set to that function's prototype.
You can assign shared methods or data to this prototype:

```js
function Car(make, model) {
  this.make = make
  this.model = model
}

// Add a shared method
Car.prototype.describe = function () {
  return `${this.make} ${this.model}`
}

// Add a shared property
Car.prototype.category = "vehicle"

const c = new Car("Toyota", "Camry")

console.log(c.describe()) // Toyota Camry
console.log(c.category)    // vehicle
console.log(c instanceof Car) // true
console.log(Car.prototype) // Car: {}
console.log(Object.getPrototypeOf(c)) // Car: {}
console.log(Object.getPrototypeOf(c) === Car.prototype) // true
console.log(typeof c.prototype) // undefined
```

`Car.prototype` is the object assigned as the prototype of instances created using `new Car(...)`.
By assigning `Car.prototype.describe`, you are declaring a method on all instances created using `new Car(...)`.

Only functions intended as constructors have a `.prototype` property.
The `.prototype` is a property on `Car`, not on `c`.

Instances created with `new` have their internal `[[Prototype]]` (visible via `Object.getPrototypeOf(instance)`) set to the constructor's `.prototype`.

### Adding Properties via `.prototype`

Using `.prototype`, you can add any properties or methods you want to a constructor function's prototype. 
These properties will then be shared across all instances created by that constructor:

```js
function Car(make, model) {
  this.make = make
  this.model = model
}

// Add a shared method
Car.prototype.describe = function () {
  return `${this.make} ${this.model}`
}

// Add a shared property
Car.prototype.type = "vehicle"

const c1 = new Car("Toyota", "Camry")
const c2 = new Car("Honda", "Accord")

console.log(c1.describe())  // Toyota Camry
console.log(c2.describe())  // Honda Accord
console.log(c1.type)        // vehicle
console.log(c2.type)        // vehicle
```

You can add any property—functions, strings, numbers, objects, even symbols:

```js
Car.prototype.mileage = 0
Car.prototype.getInfo = function () {
  return `${this.make} ${this.model}, mileage: ${this.mileage}`
}
```

### The Effect of `.prototype`

If you start with an object created via `new` and then add a property to its constructor's `.prototype`, 
that new property will be shared by all instances (past and future) created with that constructor, 
but only if they haven't overridden the property directly:

```js
function Car(make, model) {
  this.make = make
  this.model = model
}

const c1 = new Car("Toyota", "Camry")
const c2 = new Car("Honda", "Civic")

// Add a new method after both objects were created
Car.prototype.describe = function () {
  return `${this.make} ${this.model}`
}

console.log(c1.describe()) // Toyota Camry
console.log(c2.describe()) // Honda Civic
```

Because `describe` was added to `Car.prototype`, both `c1` and `c2` gain access to it even after they were created. 
That's the power of the prototype chain.

If you write:

```js
c1.prototype.describe = function () {
  return `${this.make} ${this.model}`
}
```

it does not work the way you might expect. Here's why:

* `c1` is an instance, not a constructor.
* Instances do not have a `prototype` property.
* Only functions (which can be used as constructors) have a `.prototype` property.

So `c1.prototype` is `undefined`, and assigning to it has no effect on `c1` or any other object.

If you want to modify only `c1`, assign directly:

```js
c1.describe = function () {
  return `${this.make} ${this.model}`
}
```

Arrow functions do not have a `.prototype` property:

```js
const arrow = () => {}
console.log(arrow.prototype) // undefined
```

Methods (defined inside objects or classes) also do not have their own `.prototype` property:

```js
const obj = {
  method() {}
}
console.log(obj.method.prototype) // undefined
```

### Conventional Method Names

In JavaScript, method names like `describe` are not required to follow any naming convention.
They're just regular property names.
However, developers often adopt informal naming conventions to make code easier to understand.

The name `describe` is a common convention.
It implies that the method returns a human-readable description of the object.
Other similar convention-based names might include:

- `toString()`: Return a string representation
- `describe()`: Provide a descriptive summary
- `equals(other)`: Compare with another instance
- `clone()`: Return a shallow or deep copy
- `reset()`: Restore default state
- `initialize()`: One-time setup after construction

These names aren't enforced by JavaScript but are part of conventional usage patterns shared across libraries and frameworks.

### The Internal `[[Prototype]]` Link

The double square brackets `[[Prototype]]` indicate an internal property of JavaScript objects.
This is not something you can access or manipulate directly in code using normal property access (like `obj.[[Prototype]]`).
Instead, it's a specification-level term used in the ECMAScript standard to describe the internal linkage between objects.

Each object in JavaScript has an internal `[[Prototype]]` link to another object. 
This forms a prototype chain used for property lookup.

```ts
const animal = {
  sound: "generic noise",
  speak() {
    return this.sound
  }
}

const dog = Object.create(animal)
dog.sound = "woof"
console.log(dog.speak()) // woof
```

If `speak` were not found on `dog`, JavaScript would follow `dog.__proto__` to `animal` to find it.

### Reading and Modifying `[[Prototype]]`

In practice, you can interact with an object's prototype using `Object.getPrototypeOf(obj)` or `Object.setPrototypeOf(obj, proto)`.
In many environments, the special accessor `__proto__` also lets you view or change the prototype, though it's considered legacy.
Avoid using `__proto__` in production code. Use the standard functions instead:

```ts
Object.setPrototypeOf(obj, newProto)
Object.getPrototypeOf(obj)
```

So `[[Prototype]]` is just the formal name for the internal linkage that underlies JavaScript's prototype-based inheritance.

You cannot use `Object.setPrototypeOf(obj, proto)` to add arbitrary attributes to an object.
`Object.setPrototypeOf` sets the internal `[[Prototype]]` of `obj` to `proto`. 
This means `obj` will inherit properties and methods from `proto`, but it doesn't copy any properties directly to `obj`.

```ts
const proto = { greeting: "hello" }
const obj = {}

Object.setPrototypeOf(obj, proto)

// Inherited via prototype:
console.log(obj.greeting) // "hello" 
// Not a direct property:
console.log(obj.hasOwnProperty("greeting")) // false
```

Any properties on the prototype will appear accessible on `obj` through the prototype chain, but they are not stored on `obj` itself.
For example, you cannot do something like this:

```ts
setPrototypeOf(child, 42)
```

and expect it to work as if you're assigning a new top-level property. 
You're modifying the prototype object itself, which could be valid, but that's a separate object, not the child directly.

### Additional prototype methods:

- `Object.create(proto)`: Creates a new object with its internal prototype set to proto.

```ts
const base = { greet: () => "hello" }
const child = Object.create(base)
console.log(child.greet()) // "hello"
```

- `Object.prototype.isPrototypeOf(obj)`: Checks whether the object appears in the prototype chain of obj.

```ts
const parent = {}
const child = Object.create(parent)
console.log(parent.isPrototypeOf(child)) // true
```

- `obj.hasOwnProperty(prop)`:  Returns true if the property exists directly on the object (not via the prototype chain).

```ts
const obj = Object.create({ inherited: true })
obj.own = true
console.log(obj.hasOwnProperty("own")) // true
console.log(obj.hasOwnProperty("inherited")) // false
```

- `Object.getOwnPropertyDescriptors(obj)`: Returns all property descriptors for an object's own (non-inherited) properties. 
  Helpful for understanding how inheritance and property attributes behave.

### Prototypes Are Live

If you modify a prototype object after it's been assigned, the change affects all objects that inherit from it.

```ts
const base = {}
const child = Object.create(base)

base.greet = () => "hello"
console.log(child.greet()) // "hello"
```

This dynamic nature means modifying prototypes can have wide-reaching effects and should be done with caution.

### Prototype Chain Depth

The prototype chain eventually terminates at `Object.prototype`, whose prototype is `null`.

```ts
const obj = {}
console.log(Object.getPrototypeOf(obj)) // Object.prototype
console.log(Object.getPrototypeOf(Object.prototype)) // null
```

You can use this knowledge to perform safe prototype traversal or detect objects with no prototype (via `Object.create(null)`).

### `Object.create(null)`

You can create a "bare" object with no prototype:

```ts
const dict = Object.create(null)
dict.key = "value"
console.log(dict.toString) // undefined: not inherited
```

This is useful for dictionary-like objects where you want to avoid conflicts with inherited keys like `toString`.

### Performance Considerations

Modifying the prototype of an existing object (e.g., with `Object.setPrototypeOf`) 
is slower than creating it with the desired prototype from the start (`Object.create`). 
If you're writing performance-critical code, avoid changing prototypes dynamically.

## The JavaScript Prototype Model

JavaScript’s object system is fundamentally different from classical object-oriented languages.
At its core, JavaScript uses *prototype-based inheritance*, and understanding how constructors and prototypes work together is essential to mastering the language.
Understanding how JavaScript handles constructors and prototypes is crucial for working effectively with its object model.

Constructors are simply functions invoked with `new`, and the `.prototype` property provides a shared mechanism for inheritance.
By mastering how prototypes link instances and support shared behavior,
you gain a deep understanding of JavaScript’s core object system and how features like classes are built on top of it.

### The Prototype Property

Every function in JavaScript has a `prototype` property by default.
This is an object that becomes the prototype of any instance created using that function as a constructor.

The `prototype` serves as the *shared space for instance methods and properties*.
Rather than duplicating methods for every instance, JavaScript allows all instances to delegate behavior to this shared prototype object.

```js
Car.prototype.describe = function() {
  return `${this.make} ${this.model}`;
};

console.log(myCar.describe()); // "Toyota Camry"
```

#### When Does a Function Get a Prototype?

A function gets a `.prototype` property *as soon as it is defined*.
This happens whether the function is ever used as a constructor.
It's simply part of how JavaScript sets up normal functions.

```js
function regularFunction() {}
console.log(typeof regularFunction.prototype); // "object"
```

Note: this does *not* apply to arrow functions.

```js
const arrow = () => {};
console.log(arrow.prototype); // undefined
```

Arrow functions do not get a `.prototype` because they are not designed to be used with `new`.

Every function in JavaScript has a `prototype` property by default.
This is an object that becomes the prototype of any instance created using that function as a constructor.

The `prototype` serves as the shared space for instance methods and properties.
Rather than duplicating methods for every instance, JavaScript allows all instances to delegate behavior to this shared prototype object.

```js
Car.prototype.describe = function() {
  return `${this.make} ${this.model}`;
};

console.log(myCar.describe()); // "Toyota Camry"
```

### Shared Prototypes Across Instances

All objects created from the same constructor share the same prototype.
This means they all have access to the same methods without duplicating them.

```js
const car1 = new Car("Honda", "Accord");
const car2 = new Car("Ford", "Focus");

console.log(car1.describe()); // "Honda Accord"
console.log(car2.describe()); // "Ford Focus"
console.log(car1.describe === car2.describe); // true
```

### Constructors vs. Regular Functions

In JavaScript, a *constructor* is simply a function used to create new objects.
What makes a function a constructor isn’t its declaration, but how it is called.
When a function is invoked with the `new` keyword, it acts as a constructor.

Here's what happens when a function is called with `new`:

1. A new empty object is created.
2. That object’s prototype is set to the function’s `.prototype` property.
3. The constructor function is executed with `this` bound to the new object.
4. If the function does not explicitly return an object, the new object is returned by default.

```js
function Car(make, model) {
  this.make = make;
  this.model = model;
}

const myCar = new Car("Toyota", "Camry");
console.log(myCar); // { make: "Toyota", model: "Camry" }
```

From a syntactic point of view, there’s no special “constructor” keyword (outside of `class`) in JavaScript.
Any function can be used as a constructor simply by calling it with `new`.

Example of misuse:

```js
function Dog(name) {
  this.name = name;
}

const notADog = Dog("Buster"); // this.name is set on global object (or undefined in strict mode)
const properDog = new Dog("Buster"); // creates new Dog instance
```

Modern JavaScript introduces `class` syntax, which clarifies this distinction by enforcing that classes can only be called with `new`.

```js
class Dog {
  constructor(name) {
    this.name = name;
  }
}

const fido = new Dog("Fido");
```

### Return Values in Constructors

Constructors typically don't return anything explicitly.
However, they *can*, depending on what is returned:

* If the constructor returns an object (e.g. `{}`), that object replaces the newly created one.
* If it returns a primitive value (e.g., a string or number), that value is ignored, and the newly constructed object is returned as usual.
* If it returns `undefined`, which is the default, the new object is returned.

```js
function Custom() {
  this.foo = "bar";
  return { override: true };
}

const obj = new Custom();
console.log(obj); // { override: true }
```

In class constructors, this behavior is more restricted.
While base class constructors can return objects, derived classes cannot; doing so will trigger a `TypeError`.

### Prototype Chaining and Inheritance

JavaScript uses a *prototype chain* to implement inheritance.
When a property or method is accessed on an object, JavaScript checks:

1. Does the object itself have the property?
2. If not, it follows the object's internal `[[Prototype]]` link to its constructor’s prototype.
3. This lookup continues up the chain until the property is found or the prototype is `null`.

This mechanism allows methods to be shared and overridden.
If a method exists on a child prototype that matches one higher up the chain, the closer version takes precedence.

```js
function Animal() {}
Animal.prototype.speak = function() {
  return "generic sound";
};

function Dog() {}
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;
Dog.prototype.speak = function() {
  return "woof";
};

const fido = new Dog();
console.log(fido.speak()); // "woof"
```

In this case, `Dog.prototype.speak` overrides `Animal.prototype.speak`.
JavaScript finds the overridden method first when resolving `fido.speak()`.

If desired, the parent method can still be invoked explicitly:

```js
Animal.prototype.speak.call(fido); // "generic sound"
```

This lookup applies to all properties, not just methods:

```js
console.log(Object.getPrototypeOf(fido) === Dog.prototype); // true
console.log(Dog.prototype.__proto__ === Animal.prototype);  // true
```

Prototype chain:

```text
fido → Dog.prototype → Animal.prototype → Object.prototype → null
```

```js
function Animal() {}
Animal.prototype.speak = function() {
  return "generic sound";
};

function Dog() {}
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.speak = function() {
  return "woof";
};

const fido = new Dog();
console.log(fido.speak()); // "woof"
````

In this example, `Dog.prototype.speak` overrides `Animal.prototype.speak`.
When `fido.speak()` is called, JavaScript finds the method on `Dog.prototype` and stops searching.
The `Animal.prototype` version is still present but no longer used unless explicitly called.

An explicit call:

```js
Animal.prototype.speak.call(fido); // "generic sound"
```


### Classes and Modern Syntax

The `class` syntax introduced in ES6 provides a clearer, more familiar way to define constructors and prototypes.
Under the hood, it’s still using the same prototype-based mechanism:

```js
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    return `${this.name} makes a sound.`;
  }
}

const pet = new Animal("Charlie");
console.log(pet.speak()); // "Charlie makes a sound."
```

Classes provide structure by requiring `new` and limiting constructor behavior.

## Constructor Functions

Before `class` syntax was introduced in ES6, constructor functions were the primary way to create object blueprints:

```ts
function Name(first, last) {
  this.first = first
  this.last = last
}

Name.prototype.describe = function () {
  return `${this.first} ${this.last}`
}

const c = new Name("Morty", "Smith")
console.log(c.describe()) // Morty Smith
```

Using `new` sets the prototype of the constructed object to `Name.prototype`.

## Class Syntax

ES6 introduced the `class` keyword as a more familiar way to declare constructors and prototypes, 
especially for developers coming from class-based languages like Java, C#, or C++.

```ts
class Shape {
  constructor(name) {
    this.name = name
  }
  describe() {
    return `This is a ${this.name}`
  }
}

const s = new Shape("circle")
console.log(s.describe()) // This is a circle
console.log(Shape.prototype.describe) // Produces describe() code
```

Under the hood, `class` still uses prototypes and constructor functions.

Fields are defined directly on class instances:

```ts
class Counter {
  count = 0
  increment() {
    this.count++
  }
}
```

These are added to the instance, not the prototype.

## Inheritance with Classes

You can use `extends` to set up prototype-based inheritance between classes.

```ts
class Animal {
  speak() {
    return "noise"
  }
}

class Dog extends Animal {
  speak() {
    return super.speak() + " woof"
  }
}

const d = new Dog()
console.log(d.speak()) // noise woof
```

## `this` and Method Binding

`this` always refers to the caller's context. When passing methods around, you may lose the binding.

```ts
const user = {
  name: "Sam",
  greet() {
    return `Hello, ${this.name}`
  }
}

const greetRef = user.greet
console.log(greetRef()) // Hello, undefined
```

To fix this, bind the method:

```ts
const bound = user.greet.bind(user)
console.log(bound()) // Hello, Sam
```

## Dynamic Modification

You can add or modify properties at runtime:

```ts
const book = {}
book.title = "1984"
book.author = "George Orwell"
console.log(book)
```

You can also delete properties:

```ts
delete book.author
```

## Object Utility Functions

* `Object.create(proto)`: Creates a new object with the specified prototype.
* `Object.assign(target, source)`: Copies properties from source to target.
* `Object.entries(obj)`: Returns key-value pairs.
* `Object.keys(obj)`: Returns keys.
* `Object.values(obj)`: Returns values.

```ts
const o = { a: 1, b: 2 }
console.log(Object.entries(o)) // [['a', 1], ['b', 2]]
```

## The Constructor is a Preexisting Prototype Property

The `.prototype.constructor` property points back to the function that created the prototype. 
It is present by default and can be used to trace from an instance to its constructor.

```js
function Car(make, model) {
  this.make = make
  this.model = model
}

console.log(Car.prototype.constructor === Car) // true

const c = new Car("Toyota", "Camry")
console.log(c.constructor === Car) // true
```

- `Car.prototype.constructor` is `Car`
- `c.constructor` resolves through the prototype to `Car.prototype.constructor`
- This property can be overwritten if you're not careful when replacing `.prototype` entirely.

If you replace `.prototype` entirely, be sure to restore `.constructor` if needed:

```js
Car.prototype = {
  describe() {
    return `${this.make} ${this.model}`
  },
  constructor: Car // <- explicitly restore it
}
```

This line:

```js
console.log(Car.prototype.constructor === Car)
```

evaluates to `true` because every function in JavaScript automatically has a `.prototype` object, and by default, that `.prototype` object includes a property:

```js
constructor: <the function itself>
```

So when you write:

```js
function Car(make, model) {
  this.make = make
  this.model = model
}
```

JavaScript automatically creates a `Car.prototype` object like this:

```js
Car.prototype = {
  constructor: Car
}
```

The `constructor` property is just a reference back to the function that created the prototype. 
This helps tools, debuggers, and humans know which function created instances linked to that prototype.

A function becomes a constructor only when called with `new`:

```js
const c = new Car("Toyota", "Camry")
```

* `new` creates a new object
* It sets that object's prototype to `Car.prototype`
* It binds `this` to the new object
* It returns the result of the function (unless it returns something else explicitly)

Using `this` inside the function body is not what makes it a constructor, `new` is.

## Object Creation Patterns

The unusually rich variety of ways to create objects  in JavaScript and TypeScript can be both a strength and a source of confusion for developers coming from more rigid object-oriented languages.
This section explores sixteen different approaches to creating objects, using a simple `Circle` object as our example.
Some patterns are more common than others, but understanding the full spectrum will help you read existing codebases.

### Fundamental Approaches

#### 1. Object Literal

The object literal is JavaScript's most basic object creation syntax.
It's the closest equivalent to creating a struct or record in other languages, but with the added capability of including methods directly in the definition.

```javascript
const circle1 = {
  center: { x: 0, y: 0 },
  radius: 5,
  area() {
    return Math.PI * this.radius ** 2;
  },
};

circle1.area(); // Direct method call
```

Object literals excel in simplicity and readability.
They're perfect for configuration objects, one-off data structures, or when you need a quick object without the overhead of defining a class.
However, they don't provide any mechanism for creating multiple similar objects or enforcing consistency across instances.

#### 2. Factory Function

Factory functions solve the reusability problem of object literals by encapsulating the creation logic in a function.
This pattern is particularly popular in functional programming approaches and provides a clean way to create objects with customizable initialization logic.

```javascript
function createCircle(center, radius) {
  return {
    center,
    radius,
    area() {
      return Math.PI * radius ** 2;
    },
  };
}

const circle2 = createCircle({ x: 1, y: 2 }, 10);
```

Notice how the `area` method captures the `radius` parameter directly, demonstrating closure behavior.
Factory functions are excellent when you need custom initialization logic, want to avoid the `new` keyword, or prefer a more functional programming style.
They're also useful when you need to perform validation or computation during object creation.

### Constructor-Based Patterns

#### 3. Constructor Function

Before ES6 classes, constructor functions were JavaScript's primary mechanism for creating reusable object types.
They rely on the `new` keyword and the implicit `this` binding to create and initialize new instances.

```javascript
function Circle(center, radius) {
  this.center = center;
  this.radius = radius;
  this.area = function () {
    return Math.PI * this.radius ** 2;
  };
}

const circle3 = new Circle({ x: 0, y: 0 }, 5);
```

While this pattern works, it has a significant drawback: every instance gets its own copy of the `area` method, which wastes memory when you create many objects.
This is where the prototype pattern becomes valuable.

#### 4. Constructor Function with Prototype

The prototype pattern addresses the memory inefficiency of basic constructor functions by sharing methods across all instances.
This is how JavaScript implements something similar to class methods in traditional OOP languages.

```javascript
function CircleProto(center, radius) {
  this.center = center;
  this.radius = radius;
}

CircleProto.prototype.area = function () {
  return Math.PI * this.radius ** 2;
};

const circle4 = new CircleProto({ x: 3, y: 4 }, 5);
```

This pattern is more memory-efficient because all instances share the same `area` function through the prototype chain.
Understanding prototypes is crucial for JavaScript mastery, as they underpin the language's inheritance model.
Even modern ES6 classes are syntactic sugar over this prototype system.

### Modern Class Syntax

#### 5. ES6 Class

ES6 introduced class syntax that provides a more familiar interface for developers coming from class-based languages like Java or C#.
Under the hood, this creates the same prototype-based structure as the previous example, but with cleaner, more readable syntax.

```javascript
class CircleClass {
  constructor(center, radius) {
    this.center = center;
    this.radius = radius;
  }
  
  area() {
    return Math.PI * this.radius ** 2;
  }
}

const circle5 = new CircleClass({ x: 1, y: 1 }, 5);
```

Classes provide better tooling support, clearer inheritance syntax, and are generally easier to read and maintain.
They're the recommended approach for most object-oriented programming in modern JavaScript and TypeScript.

#### 6. TypeScript Class with Type Annotations

TypeScript enhances the class syntax with static type checking and convenient property declaration shortcuts.
The `public` modifier in the constructor parameters automatically creates and initializes instance properties.

```typescript
type Point = { x: number; y: number };

class CircleTS {
  constructor(public center: Point, public radius: number) {}
  
  area(): number {
    return Math.PI * this.radius ** 2;
  }
}

const circle6 = new CircleTS({ x: 2, y: 2 }, 7);
```

This approach combines the benefits of static typing with concise syntax.
The compiler will catch type errors at build time, and IDEs can provide better autocomplete and refactoring support.
The parameter properties feature (`public center: Point`) is particularly useful for reducing boilerplate in simple classes.

### Advanced Object Creation Techniques

#### 7. Object.create with Null Prototype

`Object.create(null)` creates an object without any prototype chain, resulting in a "clean" object with no inherited properties or methods.
This is particularly useful for creating dictionary-like objects where you want to avoid conflicts with inherited properties.

```javascript
const circle7 = Object.create(null);
circle7.center = { x: 0, y: 0 };
circle7.radius = 5;
circle7.area = function () {
  return Math.PI * this.radius ** 2;
};
```

Objects created this way won't have methods like `toString()` or `hasOwnProperty()`.
This prevents property name conflicts and unexpected behavior when using the object as a pure data container or hash map.
For example, if someone assigns data to a property named "toString" on a regular object,
it will override the inherited method and cause errors when that method is later called.
With `Object.create(null)`, property names like "toString" or "constructor" are treated as ordinary data without any special meaning.
However, this can also be confusing for developers who expect standard object behavior like being able to call `.toString()` on any object.

#### 8. Object.defineProperty for Fine-Grained Control

When you need precise control over property attributes--such as making properties non-writable, non-enumerable, or non-configurable--`Object.defineProperty` and `Object.defineProperties` provide the necessary power.

```javascript
const circle8 = {};
Object.defineProperties(circle8, {
  center: {
    value: { x: 0, y: 0 },
    writable: true,
  },
  radius: {
    value: 5,
    writable: true,
  },
  area: {
    value: function () {
      return Math.PI * this.radius ** 2;
    },
  },
});
```

This approach is verbose but gives you complete control over how properties behave.
You can create read-only properties, hidden properties that don't show up in `Object.keys()`, or properties that can't be deleted.
It's rarely needed in everyday programming but essential for library authors and framework developers.

### Specialized Patterns

#### 9. Static Factory Methods

Static factory methods provide alternative constructors with more descriptive names than the standard constructor.
This pattern is common in languages like Java and can make object creation more self-documenting.

```typescript
class CircleFactory {
  constructor(public center: Point, public radius: number) {}
  
  static fromDiameter(center: Point, diameter: number): CircleFactory {
    return new CircleFactory(center, diameter / 2);
  }
  
  area(): number {
    return Math.PI * this.radius ** 2;
  }
}

const circle9 = CircleFactory.fromDiameter({ x: 0, y: 0 }, 10);
```

Static factory methods can perform validation, choose different implementation classes based on parameters, or simply provide more intuitive creation methods.
They're particularly useful when you have multiple ways to construct an object or when the construction logic is complex.

#### 10. Class Expressions

Just as you can assign functions to variables, you can assign classes to variables using class expressions.
This is useful for creating anonymous classes or when you need to conditionally define different class implementations.

```javascript
const CircleExpr = class {
  constructor(center, radius) {
    this.center = center;
    this.radius = radius;
  }
  
  area() {
    return Math.PI * this.radius ** 2;
  }
};

const circle10 = new CircleExpr({ x: 1, y: 1 }, 3);
```

Class expressions are less common than class declarations but can be useful in scenarios where you need to create classes dynamically or pass classes as arguments to other functions.

#### 11. Singleton Pattern with IIFE

The Immediately Invoked Function Expression (IIFE) pattern can create singleton objects--instances where only one copy should ever exist.
This pattern encapsulates the creation logic and ensures the object is created exactly once.

```javascript
const CircleSingleton = (function () {
  const center = { x: 0, y: 0 };
  const radius = 5;
  return {
    center,
    radius,
    area() {
      return Math.PI * radius ** 2;
    },
  };
})();
```

This pattern was more common before ES6 modules provided better encapsulation mechanisms.
It's still useful for creating configuration objects or shared state that should be initialized exactly once.

### Esoteric and Specialized Techniques

#### 12. Symbol-Based Methods

Symbols can be used as property keys to create methods that are not easily accessible through normal property enumeration.
This is useful for creating "internal" methods or implementing well-known symbols like `Symbol.iterator`.

```javascript
const circle12 = {
  center: { x: 0, y: 0 },
  radius: 5,
  [Symbol.for("area")]() {
    return Math.PI * this.radius ** 2;
  },
};
```

Symbol-based properties won't appear in `Object.keys()` or `for...in` loops, providing a form of "privacy" though they're still accessible if you have the symbol reference.
This technique is more commonly used in library code than application code.

#### 13. Proxy-Based Objects

Proxies allow you to intercept and customize operations performed on objects, such as property access, assignment, and method calls.
This enables powerful metaprogramming capabilities.

```javascript
function CircleProxy(center, radius) {
  const target = {
    center,
    radius,
    area() {
      return Math.PI * this.radius ** 2;
    },
  };
  
  return new Proxy(target, {
    get(obj, prop) {
      console.log(`Accessing ${String(prop)}`);
      return obj[prop];
    },
  });
}

const circle13 = CircleProxy({ x: 1, y: 1 }, 6);
```

Proxies are powerful but come with performance overhead.
They're useful for debugging, implementing reactive systems, or creating objects with dynamic behavior.
Many modern frameworks use proxies internally for features like reactive data binding.

#### 14. JSON Deserialization with Method Attachment

When working with data from APIs or storage, you might need to reconstruct objects with methods from plain JSON data.
This pattern shows how to restore functionality to deserialized objects.

```javascript
const json = '{"center":{"x":2,"y":3},"radius":4}';
const parsed = JSON.parse(json);
parsed.area = function () {
  return Math.PI * this.radius ** 2;
};

const circle14 = parsed;
```

This approach is common when building applications that persist object state or receive complex data from external sources.
You might extend this pattern with helper functions that can reconstruct entire object hierarchies with their associated methods.

#### 15. TypeScript Record Types

TypeScript's `Record` utility type provides a way to create objects with specific key-value type constraints.
While not commonly used for object creation, it demonstrates TypeScript's advanced type system capabilities.

```typescript
type CircleRec = Record<"center" | "radius", unknown> & {
  area: () => number;
};

const circle15: CircleRec = {
  center: { x: 0, y: 0 },
  radius: 5,
  area: () => Math.PI * 5 ** 2,
};
```

This pattern is more about type constraints than object creation, but it shows how TypeScript can enforce object shapes in sophisticated ways.
It's particularly useful when working with dynamic data where you need to ensure certain properties exist.

#### 16. Private Fields with Hash Syntax

Modern JavaScript and TypeScript support true private fields using the hash (`#`) syntax.
Unlike TypeScript's `private` modifier, these are enforced at runtime and provide genuine encapsulation.

```javascript
class CirclePrivate {
  #center;
  #radius;
  
  constructor(center, radius) {
    this.#center = center;
    this.#radius = radius;
  }
  
  area() {
    return Math.PI * this.#radius ** 2;
  }
}

const circle16 = new CirclePrivate({ x: 0, y: 0 }, 3);
```

Private fields cannot be accessed from outside the class, even through reflection or property access tricks.
This provides stronger encapsulation than TypeScript's compile-time `private` modifier, though it comes with the cost of slightly more complex syntax.
